#!/usr/bin/perl -w

use Data::Dumper; # TODO: remove this at some point
use JSON qw( encode_json );

# george caley presents:
# perl2python
# a COMP2041 assignment

# --== LEXER ==--

# token types
use constant TOKENS => qw(
	COMMENT
	WORD
	SCALAR
	STRING
	NUMBER
	SEMICOLON
	EQUALS DOUBLEEQUALS POINT MATCH
	GREATER_THAN GREATER_EQUALS LESS_THAN LESS_EQUALS
	NOT_EQUALS LOGICAL_NOT
	SHIFT_LEFT SHIFT_RIGHT
	BIT_OR BIT_AND LOGICAL_OR LOGICAL_AND
	XOR BIT_NOT
	PARENTHESIS_OPEN PARENTHESIS_CLOSE
	SQUARE_OPEN SQUARE_CLOSE
	CURLY_OPEN CURLY_CLOSE
	COMMA
	PLUS INCREMENT
	MINUS DECREMENT
	MUL POW
	DIV
);

# single char token mappings
# this will hopefully clean up the lexer code a bit
# anything slightly less trivial (e.g. =, which is special because we need to test ==) 
# will need its own code
%singleCharTokens = (
	";" => SEMICOLON,
	"(" => PARENTHESIS_OPEN,
	")" => PARENTHESIS_CLOSE,
	"[" => SQUARE_OPEN,
	"]" => SQUARE_CLOSE,
	"{" => CURLY_OPEN,
	"}" => CURLY_CLOSE,
	"," => COMMA,
	"/" => DIV,
	"^" => XOR,
	"~" => BIT_NOT
);

# tokeniser states
use constant STATES => qw(
	STATE_IDLE
	STATE_COMMENT
	STATE_WORD
	STATE_SCALAR
	STATE_ARRAY
	STATE_HASH
	STATE_STRING
	STATE_NUMBER
);

# tokens are stored as hashes of type and value

sub makeToken {
	my $type = shift;

	my $token = {};
	$token->{"type"} = $type;

	my $value = shift;
	if (defined $value) {
		$token->{"value"} = $value;
	}

	#print "making token ", %$token, "\n";

	return $token;
}

sub tokenise {
	my $data = shift;

	# data is just the text from the python file
	# it's now our job to chop it up into tokens
	# yay......

	# add newline to data (makes detecting the end of the last line easier)
	$data .= "\n";
	my @chars = split(//, $data);

	# initialise state machine
	my $state = STATE_IDLE;

	# initialise token array
	my @tokens = ();

	# here is a string to store token value
	my $value = "";

	# initialise current char counter
	my $i = 0;

	while ($i < @chars) {

		my $curr = $chars[$i]; # current char
		my $next = $chars[$i+1]; # next char

		my $token;

		if ($state eq STATE_IDLE) {
			if (defined $singleCharTokens{$curr}) {
				# use a single char token mapping
				push @tokens, makeToken($singleCharTokens{$curr});
				# remain in the idle state
			} elsif ($curr eq "#") {
				# start reading comment
				$state = STATE_COMMENT;
			} elsif ($curr eq "=") {
				# is it double equals?
				if ($next eq "=") {
					$token = makeToken(DOUBLEEQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(POINT);
					$i++;
				} elsif ($next eq "~") {
					$token = makeToken(MATCH);
					$i++;
				} else {
					$token = makeToken(EQUALS);
				}

				push @tokens, $token;
			} elsif ($curr eq ">") {
				if ($next eq "=") {
					$token = makeToken(GREATER_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(SHIFT_RIGHT);
					$i++;
				} else {
					$token = makeToken(GREATER_THAN);
				}

				push @tokens, $token;
			} elsif ($curr eq "<") {
				if ($next eq "=") {
					$token = makeToken(LESS_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(SHIFT_LEFT);
					$i++;
				} else {
					$token = makeToken(LESS_THAN);
				}

				push @tokens, $token;
			} elsif ($curr eq "!") {
				if ($next eq "=") {
					$token = makeToken(NOT_EQUALS);
					$i++;
				} else {
					$token = makeToken(LOGICAL_NOT);
				}

				push @tokens, $token;
			} elsif ($curr eq "&") {
				if ($next eq "&") {
					$token = makeToken(LOGICAL_AND);
					$i++;
				} else {
					$token = makeToken(BIT_AND);
				}

				push @tokens, $token;
			} elsif ($curr eq "|") {
				if ($next eq "|") {
					$token = makeToken(LOGICAL_OR);
					$i++;
				} else {
					$token = makeToken(BIT_OR);
				}

				push @tokens, $token;
			} elsif ($curr eq "*") {
				# is it pow?
				if ($next eq "*") {
					$token = makeToken(POW);
					$i++;
				} else {
					$token = makeToken(MUL);
				}

				push @tokens, $token;
			} elsif ($curr eq "+") {
				# is it increment?
				if ($next eq "+") {
					$token = makeToken(INCREMENT);
					$i++;
				} else {
					$token = makeToken(PLUS);
				}

				push @tokens, $token;
			} elsif ($curr eq "-") {
				# is it decrement?
				if ($next eq "-") {
					$token = makeToken(DECREMENT);
					$i++;
				} else {
					$token = makeToken(MINUS);
				}

				push @tokens, $token;
			} elsif ($curr eq '"' || $curr eq "'") {
				# start reading string
				$state = STATE_STRING;
                $separator = $curr;
			} elsif ($curr eq "\$") {
				# start reading scalar
				$state = STATE_SCALAR;
			} elsif ($curr eq "@") {
				# start reading array
				$state = STATE_ARRAY;
			} elsif ($curr eq "%") {
				# start reading hash
				$state = STATE_HASH;
			} elsif ($curr =~ /[A-Za-z_]/) {
				# start reading a word (stuff like keywords, function names, etc.)
				$state = STATE_WORD;
				next;
				#$value .= $curr;
			} elsif ($curr =~ /[0-9]/) {
				# start reading number
				$state = STATE_NUMBER;
				next;
				#$value .= $curr;
			}
		} elsif ($state eq STATE_COMMENT) {
			if ($curr eq "\n") {
				# newline! end of comment
				push @tokens, makeToken(COMMENT, $value);

				$state = STATE_IDLE;
				$value = "";
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_STRING) {
			# keep reading until we hit the end quote
			if ($curr eq $separator) {
				# we're done
				push @tokens, makeToken(STRING, $value);

				$state = STATE_IDLE;
				$value = "";
			} elsif ($curr eq "\\") {
				# is it a backslash followed by a quote?
				if ($next eq $separator) {
                    # consume just the quote
					$value .= $next;
					$i++;
                } elsif ($next eq "\\") {
                    # consume both backslashes
                    $value .= $curr;
                    $value .= $next;
                    $i++;
				} else {
                    # consume it like normal
                    $value .= $curr;
                }
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_SCALAR || $state eq STATE_ARRAY || $state eq STATE_HASH) {
			# consume char
			$value .= $curr;

			# keep reading until we hit something unusual
			if (!($next =~ /[A-Za-z0-9_]/)) {
				# end of name
				if ($state eq STATE_SCALAR) {
					$type = SCALAR;
				} elsif ($state eq STATE_ARRAY) {
					$type = ARRAY;
				} elsif ($state eq STATE_HASH) {
					$type = HASH;
				}

				push @tokens, makeToken($type, $value);

				$state = STATE_IDLE;
				$value = "";
			}
		} elsif ($state eq STATE_WORD) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[A-Za-z0-9_]/)) {
				# end of function name/loop/something like that
				# check for logical operators like and, or, not
				if ($value eq "and") {
					push @tokens, makeToken(LOGICAL_AND);
				} elsif ($value eq "or") {
					push @tokens, makeToken(LOGICAL_OR);
				} elsif ($value eq "not") {
					push @tokens, makeToken(LOGICAL_NOT);
				} else {
					push @tokens, makeToken(WORD, $value);
				}

				$state = STATE_IDLE;
				$value = "";
			}
		} elsif ($state eq STATE_NUMBER) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[0-9]/)) {
				# end of number
				push @tokens, makeToken(NUMBER, $value);

				$state = STATE_IDLE;
				$value = "";
			}
		}

		$i++;

	}

	return @tokens;

}

# --== PARSER ==--

use constant AST_NODES => qw(
	NODE_STATEMENTS
	NODE_COMMENT
	NODE_CALL
	NODE_VARIABLE
	NODE_ARRAY
	NODE_HASH
);

# the parser operates on a few global variables
# the token array and the current token counter
@tokens = ();
$upto = 0;

sub parse {
	my $statements_ref = parse_statements();

	my %node = (
		"type" => NODE_STATEMENTS,
		"children" => $statements_ref
	);

	return \%node;
}

sub parse_statements {
	# parse numerous statements
	# TODO: if/while loops

	my @statements = ();

	while ($upto <= $#tokens) {
		push @statements, parse_statement();
	}

	return \@statements;
}

sub parse_statement {
	# parse a single statement

	# the only thing that exists so far is calls
	my $call_ref = parse_call();

	# consume semicolon
	# om nom nom
	if ($upto <= $#tokens) {
		my %curr = %{$tokens[$upto]};
		($curr{"type"} eq SEMICOLON) or die "Expecting semicolon";
		$upto++;
	}

	return $call_ref;
}

sub parse_call {
	# get the name of the call
	my %curr = %{$tokens[$upto]};
	my $name = $curr{"value"};
	print "parsing call $name\n";
	$upto++;

	# parse arguments
	my $args_ref = parse_args();

	# assemble a node
	my %node = (
		"type" => NODE_CALL,
		"name" => $name,
		"children" => $args_ref
	);

	return \%node;
}

sub parse_args {
	# we'll know we're at the end when we hit either:
	# (1) closing parenthesis (assuming there was an opening one)
	# (2) semicolon

	# initialise array of args
	my @args = ();

	# check for parentheses
	my $parentheses = 0;

	my %curr = %{$tokens[$upto]};
	if ($curr{"type"} eq PARENTHESIS_OPEN) {
		$parentheses = 1;
		$upto++;
	}

	my $first = 1;

	while ($upto <= $#tokens) {
		my %curr = %{$tokens[$upto]};
		my %next;

		if ($upto < $#tokens) {
			%next = %{$tokens[$upto+1]};
		} else {
			undef %next;
		}

		if ($curr{"type"} eq PARENTHESIS_CLOSE) {
			# ...were we expecting it?
			if ($parentheses) {
				# consume the closing parenthesis
				$upto++;
				last;
			} else {
				# end anyway, but don't consume anything
				# nested functions, what even
				last;
			}
		} elsif ($curr{"type"} eq SEMICOLON) {
			# don't actually eat the semicolon, leave that to parse_statement
			last;
		} else {
			# must be an argument
			# if it's not the first arg, we need to consume the comma too
			if (!$first) {
				($curr{"type"} eq COMMA) or die "Expecting comma";
				$upto++;
			}
			
			push @args, parse_arg();
		}

		$first = 0;
	}

	# return the arguments (by reference)
	return \@args;
}

sub parse_arg {
	# wtf is an arg
	return parse_expr();
}

sub parse_expr {
	my %curr = %{$tokens[$upto]};

	print "reading expr, starting with ", $curr{"type"}, "\n";

	# is it a call?
	if ($curr{"type"} eq WORD) {
		return parse_call();
	}

	# is it a variable?
	if (($curr{"type"} eq SCALAR) || ($curr{"type"} eq ARRAY) || ($curr{"type"} eq HASH)) {
		return parse_var();
	}

	# must be a literal
	$upto++;
	return \%curr;
}

sub parse_var {
	my %curr = %{$tokens[$upto]};
	$upto++;

	my %node = (
		"name" => $curr{"value"}
	);

	if ($curr{"type"} eq SCALAR) {
		$node{"type"} = NODE_VARIABLE;

		# are we indexing an array/hash?
		my %next = %{$tokens[$upto]};
		if ($next{"type"} eq SQUARE_OPEN) {
			# array indexing
			$upto++;
			$node{"index"} = parse_expr();

			# consume closing bracket
			%next = %{$tokens[$upto]};
			($next{"type"} eq SQUARE_CLOSE) or die "Expecting closing square bracket";
			$upto++;
		} elsif ($next{"type"} eq CURLY_OPEN) {
			# hash indexing
			$upto++;
			$node{"index"} = parse_expr();

			# consume closing bracket
			%next = %{$tokens[$upto]};
			($next{"type"} eq CURLY_CLOSE) or die "Expecting closing curly bracket";
			$upto++;
		}
		# otherwise it's a plain old scalar
	} elsif ($curr{"type"} eq ARRAY) {
		$node{"type"} = NODE_ARRAY;
	} elsif ($curr{"type"} eq HASH) {
		$node{"type"} = NODE_HASH;
	}

	return \%node;
}

# --== COMPILER ==--

# turn the AST into valid python, how bad can that be?
# ...oh god, why didn't I just use regex in the first place ;_;

# have a global for indentation level
$indent_level = 0;
use constant INDENT => "  ";

sub compile {
	# argument will just be the root of the AST

	my %node = %{$_[0]};
	my $type = $node{"type"};

	print "compiling $type\n";

	my $output = "";
	my $indent = INDENT x $indent_level;

	if ($type eq NODE_STATEMENTS) {

		# compile them one by one
		for $statement (@{$node{"children"}}) {
			$output .= compile($statement);
		}

	} elsif ($type eq NODE_CALL) {

		# check for special calls
		#my $name = "heisenberg";
		my $name = $node{"name"};
		my @args = @{$node{"children"}};

		if ($name eq "print") {
			for $i (0..$#args) {
				$output .= $indent;
				$output .= "sys.stdout.write( str( ";
				$output .= compile($args[$i]);
				$output .= " ) ";
				$output .= ")";
				$output .= "\n";
			}
		}

	} elsif ($type eq STRING) {

		# easy mode
		my $value = $node{"value"};
		$value =~ s/"/\\"/;
		$output .= '"' . $value . '"';
	}

	return $output;
}

# --== MAIN STUFF ==--

# create list of files from arguments
@files = @ARGV;
# if it's empty, add stdin
if (@ARGV == 0) {
	push @files, "-";
}

foreach $file (@files) {

	open(F, "< $file");

	$data = "";
	while (<F>) {
		$data .= $_;
	}

	# initialise parser shiz
	@tokens = tokenise($data);
	$upto = 0;

	#foreach $token (@tokens) {
	#	print "token: $token ", %{$token}, "\n";
	#}

	$tree_ref = parse();
	print Dumper($tree_ref);

	$output = "import sys\n";
	$output .= compile($tree_ref);
	print "\n\n";
	print $output;

}