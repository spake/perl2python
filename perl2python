#!/usr/bin/perl -w

use Data::Dumper; # TODO: remove this at some point
use Switch;
use strict "vars";

# george caley presents:
# perl2python
# a COMP2041 assignment

our $debug = 0; # dumps the results of tokenisation and parsing
if ($#ARGV >= 0 && $ARGV[0] eq "-d") {
	$debug = 1;
	shift @ARGV;
}

# --== LEXER ==--

# token types
use constant TOKENS => qw(
	COMMENT
	NEWLINE
	WORD
	SCALAR ARRAY HASH
	STRING STRING_INTERPOLATED
	NUMBER
	SEMICOLON
	EQUALS DOUBLE_EQUALS POINT MATCH
	GREATER_THAN GREATER_EQUALS LESS_THAN LESS_EQUALS
	NOT_EQUALS LOGICAL_NOT
	SHIFT_LEFT SHIFT_RIGHT
	BIT_OR BIT_AND LOGICAL_OR LOGICAL_AND
	XOR BIT_NOT
	PARENTHESIS_OPEN PARENTHESIS_CLOSE
	SQUARE_OPEN SQUARE_CLOSE
	CURLY_OPEN CURLY_CLOSE
	COMMA
	PLUS INCREMENT
	MINUS DECREMENT
	MUL POW
	DIV
	MOD
	CONCAT
	REASSIGN
	RANGE
	HANDLE_INPUT
	HANDLE_INPUT_MULTILINE
	REGEX
);
# 'reassign' is a special token that can succeed operations
# just a hacky way of dealing with +=, -=, *=, &=, etc.
# 'HANDLE_INPUT' is something of the form <F>, <STDIN>, <>, etc.
# the multiline variant is for assignment of a file handle to an array and is only used by the compiler

# single char token mappings
# this will hopefully clean up the lexer code a bit
# anything slightly less trivial (e.g. =, which is special because we need to test ==) 
# will need its own code
our %singleCharTokens = (
	";" => SEMICOLON,
	"(" => PARENTHESIS_OPEN,
	")" => PARENTHESIS_CLOSE,
	"[" => SQUARE_OPEN,
	"]" => SQUARE_CLOSE,
	"{" => CURLY_OPEN,
	"}" => CURLY_CLOSE,
	"," => COMMA,
);

# tokeniser states
use constant STATES => qw(
	STATE_IDLE
	STATE_COMMENT
	STATE_WORD
	STATE_SCALAR
	STATE_ARRAY
	STATE_HASH
	STATE_STRING
	STATE_NUMBER
	STATE_HANDLE_INPUT
	STATE_REGEX
	STATE_REGEX_SUB
);

# tokens are stored as hashes of type and value

sub makeToken {
	my $type = shift;

	my $token = {};
	$token->{"type"} = $type;

	my $value = shift;
	if (defined $value) {
		$token->{"value"} = $value;
	}

	#print "making token ", %$token, "\n";

	return $token;
}

# string interpolation requires a weird call to the tokeniser
# we want to keep track of the index of the last variable or closing square/curly bracket
our $last_interpolation_index = 0;
our $interpolating = 0;

sub tokenise {
	my $data = shift;

	# data is just the text from the python file
	# it's now our job to chop it up into tokens
	# yay......

	# add newline to data (makes detecting the end of the last line easier)
	$data .= "\n";
	my @chars = split(//, $data);

	# initialise state machine
	my $state = STATE_IDLE;

	# initialise token array
	my @tokens = ();

	# here is a string to store token value
	my $value = "";

	# initialise current char counter
	my $i = 0;

	# nesting level, for interpolation shiz
	# (i'm crying myself to sleep at this stage)
	my $nesting = 0;

	my $seen_comment = 0;

	my $separator;
	my $type;

	while ($i < @chars) {

		my $curr = $chars[$i]; # current char
		my $next = "";
		my $next2 = "";

		if ($i+1 <= $#chars) {
			$next = $chars[$i+1]; # next char
		}
		if ($i+2 <= $#chars) {
			$next2 = $chars[$i+2]; # next *next* char!
		}

		my $token;

		if ($state eq STATE_IDLE) {
			# if we're interpolating, be sure not to enter into another variable
			# this interpolation code is the worst thing i've ever done in my life, i think
			if ($interpolating && $i > 0 && $nesting == 0 && !($curr eq "{" || $curr eq "[")) {
				last;
			}

			if (defined $singleCharTokens{$curr}) {
				# use a single char token mapping
				push @tokens, makeToken($singleCharTokens{$curr});
				# remain in the idle state

				# check if we need to update last_interpolation_index
				if (($curr eq "}") || ($curr eq "]")) {
					$last_interpolation_index = $i;
					$nesting--;

					if ($nesting == 0 && $interpolating) {
						last;
					}
				} elsif (($curr eq "{") || ($curr eq "[")) {
					$nesting++;
				}
			} elsif ($curr eq "#") {
				# start reading comment
				$state = STATE_COMMENT;
			} elsif ($curr eq "=") {
				# is it double equals?
				if ($next eq "=") {
					push @tokens, makeToken(DOUBLE_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					push @tokens, makeToken(POINT);
					$i++;
				} elsif ($next eq "~") {
					push @tokens, makeToken(MATCH);
					$i++;
				} else {
					push @tokens, makeToken(EQUALS);
				}
			} elsif ($curr eq ">") {
				if ($next eq "=") {
					push @tokens, makeToken(GREATER_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					push @tokens, makeToken(SHIFT_RIGHT);
					$i++;
					if ($next2 eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				} else {
					push @tokens, makeToken(GREATER_THAN);
				}
			} elsif ($curr eq "<") {
				if ($next eq "=") {
					push @tokens, makeToken(LESS_EQUALS);
					$i++;
				} elsif ($next eq "<") {
					# PUSH THIS NOW
					push @tokens, makeToken(SHIFT_LEFT);
					$i++;
					if ($next2 eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				} elsif ($next =~ /[A-Za-z0-9_>]/) {
					# begin reading handle input
					$state = STATE_HANDLE_INPUT;
					$i++;
					next;
				} else {
					push @tokens, makeToken(LESS_THAN);
				}
			} elsif ($curr eq "!") {
				if ($next eq "=") {
					push @tokens, makeToken(NOT_EQUALS);
					$i++;
				} else {
					push @tokens, makeToken(LOGICAL_NOT);
				}
			} elsif ($curr eq "&") {
				if ($next eq "&") {
					push @tokens, makeToken(LOGICAL_AND);
					$i++;
				} else {
					push @tokens, makeToken(BIT_AND);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "|") {
				if ($next eq "|") {
					push @tokens, makeToken(LOGICAL_OR);
					$i++;
				} else {
					push @tokens, makeToken(BIT_OR);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "*") {
				# is it pow?
				if ($next eq "*") {
					push @tokens, makeToken(POW);
					$i++;

					if ($next2 eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				} else {
					push @tokens, makeToken(MUL);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "/") {
				# was the last token a match? (/blergh/) or split (split /w+/ or split(/w+))
				# or, was the last token a word, and the token before it a match? (s/belrgh/asdfhg/)
				if ($tokens[-1]->{"type"} eq MATCH ||
					($tokens[-1]->{"type"} eq WORD && $tokens[-1]->{"value"} eq "split") ||
					($tokens[-1]->{"type"} eq PARENTHESIS_OPEN)) {
					$state = STATE_REGEX;
				} elsif ($tokens[-1]->{"type"} eq WORD && $tokens[-2]->{"type"} eq MATCH) {
					$state = STATE_REGEX_SUB;
				} else {

					# nope, just ordinary division
					push @tokens, makeToken(DIV);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}

				}
			} elsif ($curr eq "+") {
				# is it increment?
				if ($next eq "+") {
					push @tokens, makeToken(INCREMENT);
					$i++;
				} else {
					push @tokens, makeToken(PLUS);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "-") {
				# is it decrement?
				if ($next eq "-") {
					push @tokens, makeToken(DECREMENT);
					$i++;
				} else {
					push @tokens, makeToken(MINUS);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "^") {
				push @tokens, makeToken(XOR);
				if ($next eq "=") {
					push @tokens, makeToken(REASSIGN);
					$i++;
				}
			} elsif ($curr eq "~") {
				push @tokens, makeToken(BIT_NOT);
				if ($next eq "=") {
					push @tokens, makeToken(REASSIGN);
					$i++;
				}
			} elsif ($curr eq ".") {
				if ($next eq ".") {
					push @tokens, makeToken(RANGE);
					$i++;
				} elsif ($next =~ /[0-9]/) {
					# start reading a number
					$state = STATE_NUMBER;
					next;
				} else {
					push @tokens, makeToken(CONCAT);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq '"' || $curr eq "'") {
				# start reading string
				$state = STATE_STRING;
                $separator = $curr;
			} elsif ($curr eq "\$") {
				# start reading scalar
				$state = STATE_SCALAR;
			} elsif ($curr eq "@") {
				# start reading array
				$state = STATE_ARRAY;
			} elsif ($curr eq "%") {
				# start reading hash (or is it modulo?)
				$state = STATE_HASH;
			} elsif ($curr =~ /[A-Za-z_]/) {
				# start reading a word (stuff like keywords, function names, etc.)
				$state = STATE_WORD;
				next;
				#$value .= $curr;
			} elsif ($curr =~ /[0-9]/ || ($curr eq "." && $next ne ".")) {
				# start reading number
				$state = STATE_NUMBER;
				next;
				#$value .= $curr;
			} elsif ($curr eq "\n" && $next eq "\n") {
				push @tokens, makeToken(NEWLINE);
			}
		} elsif ($state eq STATE_COMMENT) {
			if ($curr eq "\n") {
				# newline! end of comment
				# was it the hashbang? cos we don't care about that shit
				if (!$seen_comment && substr($value, 0, 1) eq "!") {
					# it's a hashbang, bleh
				} else {
					push @tokens, makeToken(COMMENT, $value);
				}

				$seen_comment = 1;

				$state = STATE_IDLE;
				$value = "";
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_STRING) {
			# keep reading until we hit the end quote
			if ($curr eq $separator) {
				# we're done
				if ($separator eq "'") {
					push @tokens, makeToken(STRING, $value);
				} elsif ($separator eq '"') {
					push @tokens, makeToken(STRING_INTERPOLATED, $value);
				}

				$state = STATE_IDLE;
				$value = "";
			} elsif ($curr eq "\\") {
				# is it a backslash followed by a quote?
				if ($next eq $separator) {
                    # consume just the quote
					$value .= $next;
					$i++;
                } elsif ($next eq "\\") {
                    # consume both backslashes
                    $value .= $curr;
                    $value .= $next;
                    $i++;
				} else {
                    # consume it like normal
                    $value .= $curr;
                }
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_HANDLE_INPUT) {
			# keep reading until we hit the >
			if ($curr eq ">") {
				push @tokens, makeToken(HANDLE_INPUT, $value);

				$state = STATE_IDLE;
				$value = "";
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_REGEX || $state eq STATE_REGEX_SUB) {
			# keep reading until we hit /
			if ($curr eq "/") {
				push @tokens, makeToken(REGEX, $value);

				if ($state eq STATE_REGEX_SUB) {
					$state = STATE_REGEX; # we need to read two regexes for a substitute!
				} elsif ($state eq STATE_REGEX) {
					$state = STATE_IDLE;
				}
				$value = "";				
			} elsif ($curr eq "\\") {
				# is it a backslash followed by a forward slash? i.e. do we need to escape it
				if ($next eq "/") {
					# consume just the /
					$value .= $next;
					$i++;
				} elsif ($next eq "\\") {
					# consume both backslashes
					$value .= $curr . $curr;
					$value .= $next . $next;
					$i++;
				} else {
					# consume twice, because regex is weird
					$value .= $curr . $curr;
				}
			} else {
				# consume char!!!!!
				$value .= $curr;
			}
		} elsif ($state eq STATE_SCALAR || $state eq STATE_ARRAY || $state eq STATE_HASH) {
			# special case: if we're supposedly reading a hash, and something that doesn't look
			# like a variable name succeeds the %, read it as modulo instead
			if ($state eq STATE_HASH && length($value) == 0 && $curr =~ /[^A-Za-z]/) {
				push @tokens, makeToken(MOD);
				if ($curr eq "=") {
					push @tokens, makeToken(REASSIGN);
					$i++;
				}

				$state = STATE_IDLE;
				next; # skip moving to the next character
			} else {

				# consume char
				$value .= $curr;

				# keep reading until we hit something unusual
				if (!($next =~ /[A-Za-z0-9_]/)) {
					# end of name
					if ($state eq STATE_SCALAR) {
						$type = SCALAR;
					} elsif ($state eq STATE_ARRAY) {
						$type = ARRAY;
					} elsif ($state eq STATE_HASH) {
						$type = HASH;
					}

					push @tokens, makeToken($type, $value);
					$last_interpolation_index = $i;

					$state = STATE_IDLE;
					$value = "";
				}

			}
		} elsif ($state eq STATE_WORD) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[A-Za-z0-9_]/)) {
				# end of function name/loop/something like that
				# check for logical operators like and, or, not
				if ($value eq "and") {
					push @tokens, makeToken(LOGICAL_AND);
				} elsif ($value eq "or") {
					push @tokens, makeToken(LOGICAL_OR);
				} elsif ($value eq "not") {
					push @tokens, makeToken(LOGICAL_NOT);
				} elsif ($value eq "eq") {
					push @tokens, makeToken(DOUBLE_EQUALS, STRING);
				} elsif ($value eq "ne") {
					push @tokens, makeToken(NOT_EQUALS, STRING);
				} elsif ($value eq "gt") {
					push @tokens, makeToken(GREATER_THAN, STRING);
				} elsif ($value eq "ge") {
					push @tokens, makeToken(GREATER_EQUALS, STRING);
				} elsif ($value eq "lt") {
					push @tokens, makeToken(LESS_THAN, STRING);
				} elsif ($value eq "le") {
					push @tokens, makeToken(LESS_EQUALS, STRING);
				} else {
					# if we're interpolating, make it a string
					if ($interpolating) {
						push @tokens, makeToken(STRING, $value);
					} else {
						push @tokens, makeToken(WORD, $value);
					}
				}

				$state = STATE_IDLE;
				$value = "";
			}
		} elsif ($state eq STATE_NUMBER) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[0-9]/ || ($next eq "." && $next2 ne "."))) {
				# end of number
				push @tokens, makeToken(NUMBER, $value);

				$state = STATE_IDLE;
				$value = "";
			}
		}

		$i++;

	}

	return @tokens;

}

# --== PARSER ==--

use constant AST_NODES => qw(
	NODE_STATEMENTS
	NODE_COMMENT
	NODE_ASSIGNMENT
	NODE_EXPRESSION
	NODE_CALL
	NODE_VARIABLE
	NODE_ARRAY
	NODE_HASH

	NODE_BLOCK
	NODE_IF
	NODE_ELSEIF
	NODE_ELSE
	NODE_WHILE
	NODE_FOR
	NODE_FOREACH
	NODE_FOR_RANGE
	NODE_FOR_CLASSICAL

	NODE_ARRAY_LIST
	NODE_HASH_LIST

	NODE_REGEX

	NODE_FUNCTION

	NODE_SECTIONS
);

# everything here is basically self explanatory (I hope!)
# all nodes have a type
# for container nodes/other special stuff, it'll be one of the above nodes
# for more simple stuff that doesn't warrant translation, it'll be the same types as tokens

# some things have names
# e.g. for variables, this is the name of the variable (duh)
# for assignments, this is the variable that the result is stored in (maybe not so 'duh')
# container nodes also have children

# conditionals/loops store the condition within value, and the block (single child) within children

# the parser operates on a few global variables
# the token array and the current token counter
our @tokens = ();
our @variables = (); # so we can initialise them!
our $upto = 0;

sub parse {
	#my $statements_ref = parse_statements();
	my $sections_ref = parse_sections();

	my %node = (
		"type" => NODE_SECTIONS,
		"children" => $sections_ref
	);

	return \%node;
}

# this handles 'if', 'elsif' and 'while', since they're basically all the same thing
sub parse_if {
	# consume the type
	my %curr = %{$tokens[$upto]};
	my $if_type = $curr{"value"};
	$upto++;

	# parse the condition, but skip parentheses
	%curr = %{$tokens[$upto]};
	($curr{"type"} eq PARENTHESIS_OPEN) or die "Expecting opening parenthesis";
	$upto++;

	#my $condition_ref = parse_expr();
	my $condition_ref = parse_statement(1); # parse statement, ignoring semicolon

	%curr = %{$tokens[$upto]};
	($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expecting closing parenthesis";
	$upto++;

	# parse the block
	my $block_ref = parse_block();

	my %node = (
		"value" => $condition_ref,
		"children" => [$block_ref]
	);

	if ($if_type eq "if") {
		$node{"type"} = NODE_IF;
	} elsif ($if_type eq "elsif") {
		$node{"type"} = NODE_ELSEIF;
	} elsif ($if_type eq "while") {
		$node{"type"} = NODE_WHILE;
	}

	return \%node;
}

sub parse_else {
	# consume the 'else'
	$upto++;

	# parse the block
	my $block_ref = parse_block();

	my %node = (
		"type" => NODE_ELSE,
		"children" => [$block_ref]
	);

	return \%node;
}

sub parse_function {
	# consume the 'sub'
	$upto++;

	# consume the function name
	my %curr = %{$tokens[$upto]};
	my $function_name = $curr{"value"};
	$upto++;

	# parse the block
	my $block_ref = parse_block();

	my %node = (
		"type" => NODE_FUNCTION,
		"value" => $function_name,
		"children" => [$block_ref]
	);

	return \%node;	
}

sub parse_for {
	# consume the 'for' and its type
	my %curr = %{$tokens[$upto]};
	my $for_type = $curr{"value"};
	$upto++;

	my %node;

	# executive decision: I can't be fucked handling the anonymous variable
	# soooooo...

	# several types we have to worry about:
	# (1) for $i ($j..$k)
	# (2) for $i (@array)
	# (3) for (statement; expression; statement)
	# type 1 => for i in xrange(j, k)
	# type 2 => for i in array
	# type 3 => statement / while expression: / <block> / statement

	# read the first token
	%curr = %{$tokens[$upto]};
	#$upto++;

	# is it a variable?
	if ($curr{"type"} eq SCALAR) {
		# major league hax: use the 'name' attribute of the node as the counter variable
		$node{"name"} = parse_var();

		# so it's either type 1 or 2
		# consume the parenthesis
		%curr = %{$tokens[$upto]};
		$upto++;
		($curr{"type"} eq PARENTHESIS_OPEN) or die "Expected opening parenthesis";

		# if it's an array, it's type 2
		# otherwise type 1
		%curr = %{$tokens[$upto]};

		# parse an expression
		my $left_ref = parse_expr();

		# is there a range token?
		%curr = %{$tokens[$upto]};
		$upto++;

		if ($curr{"type"} eq RANGE) {
			# it's a range, yay
			my $right_ref = parse_expr();

			# consume the closing parenthesis
			%curr = %{$tokens[$upto]};
			$upto++;
			($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expected closing parenthesis";

			$node{"type"} = NODE_FOR_RANGE;
			$node{"value"} = [$left_ref, $right_ref];
		} else {
			# should be closing parenthesis then.
			($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expected closing parenthesis";

			$node{"type"} = NODE_FOREACH;
			$node{"value"} = $left_ref;
		}

	} elsif ($curr{"type"} eq PARENTHESIS_OPEN) {

		# classical for loop
		# consume parenthesis
		$upto++;

		# three parts:
		# (1) a statement (usually assignment)
		# (2) an expression (the condition)
		# (3) a statement (usually increment)

		my $one_ref = parse_statement();

		# consume semicolon
		#%curr = %{$tokens[$upto]};
		#$upto++;
		#($curr{"type"} eq SEMICOLON) or die "Expecting semicolon";

		my $two_ref = parse_expr();

		%curr = %{$tokens[$upto]};
		$upto++;
		($curr{"type"} eq SEMICOLON) or die "Expecting semicolon";		

		my $three_ref = parse_statement(1);

		%curr = %{$tokens[$upto]};
		$upto++;
		($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expecting closing parenthesis";

		$node{"type"} = NODE_FOR_CLASSICAL;
		$node{"value"} = [$one_ref, $two_ref, $three_ref];

	}

	# parse the block
	$node{"children"} = [parse_block()];

	return \%node;
}

sub parse_block {
	# can either be empty (a semicolon), a single line (another block), or {something in here}

	#print "reading block\n";

	my %curr = %{$tokens[$upto]};
	my $type = $curr{"type"};

	my $children = [];

	if ($type eq SEMICOLON) {
		# nothing to do here!
		# except consume it, of course.
		$upto++;
	} elsif ($type eq CURLY_OPEN) {
		# consume opening brace
		$upto++;

		#push @children, parse_sections();
		$children = parse_sections();

		# consume the closing brace
		%curr = %{$tokens[$upto]};
		($curr{"type"} eq CURLY_CLOSE) or die "Expecting closing brace";
		$upto++;
	} else {
		# a single section!? wtf
		#push @children, parse_sections();
		$children = parse_sections();
	}

	my %node = (
		"type" => NODE_SECTIONS,
		"children" => $children
	);

	return \%node;
}

sub parse_sections {
	# parse numerous sections

	my @sections = ();

	while ($upto <= $#tokens) {

		my %curr = %{$tokens[$upto]};
		my $type = $curr{"type"};

		my $name;

		# are we looking at a conditional, loop, or statement?
		if ($type eq WORD) {
			# could be...
			$name = $curr{"value"};
			if (($name eq "for") ||
				($name eq "foreach")) {
				# for loop
				push @sections, parse_for();
			} elsif ($name eq "while") {
				# while loop
				push @sections, parse_if();
			} elsif ($name eq "if") {
				# if conditional
				push @sections, parse_if();
			} elsif ($name eq "elsif") {
				# else if
				push @sections, parse_if();
			} elsif ($name eq "else") {
				# else
				push @sections, parse_else();
			} elsif ($name eq "sub") {
				# function def
				push @sections, parse_function();
			} else {
				# suppose it's none of the above then
				# parse as a statement
				push @sections, parse_statement();
			}
		} elsif ($type eq CURLY_CLOSE) {
			# end of block!
			last;
		} else {
			# parse as a statement. what else could it be?
			push @sections, parse_statement();
		}

	}

	return \@sections;
}

sub parse_statements {
	# parse numerous statements

	my @statements = ();

	while ($upto <= $#tokens) {
		push @statements, parse_statement();
	}

	return \@statements;
}

sub parse_statement {
	# parse a single statement
	my $ignore_semicolon = shift;
	if (!defined $ignore_semicolon) {
		$ignore_semicolon = 0;
	}
	#print "ignore $ignore_semicolon\n";

	my %curr = %{$tokens[$upto]};
	my %next;
	my %next2;

	if ($upto+1 <= $#tokens) {
		%next = %{$tokens[$upto+1]};
	}
	if ($upto+2 <= $#tokens) {
		%next2 = %{$tokens[$upto+2]};
	}

	my $type = $curr{"type"};
	#print "wat ".Dumper(\%curr)."\n";

	my $node_ref;

	if ($type eq COMMENT || $type eq NEWLINE) {
		$node_ref = \%curr;
		$upto++;
	} elsif (($type eq SCALAR) ||
	         ($type eq ARRAY) ||
	         ($type eq HASH)) {
		# varmod, maybe...

		# read the variable in (backup $upto first, however)
		# this is necessary to read in all the tokens constituting an index
		my $upto_backup = $upto;
		my $var_ref = parse_var();

		my %next;
		my %next2;
		if ($upto+1 <= $#tokens) {
			%next = %{$tokens[$upto]};
		}
		if ($upto+2 <= $#tokens) {
			%next2 = %{$tokens[$upto+1]};
		}

		# restore the original $upto now
		$upto = $upto_backup;

		# check for varmod
		if (defined $next{"type"} &&
			(($next{"type"} eq EQUALS) ||
			($next{"type"} eq INCREMENT) ||
			($next{"type"} eq DECREMENT) ||
			(defined $next2{"type"} && $next2{"type"} eq REASSIGN))) {

			$node_ref = parse_varmod();
		} else {
			$node_ref = parse_expr();
		}
	} else {
		# default to expression
		$node_ref = parse_expr();
	}

	# consume semicolon
	# om nom nom
	if ($upto <= $#tokens && !(($type eq COMMENT || $type eq NEWLINE) || $ignore_semicolon)) {
		%curr = %{$tokens[$upto]};

		# apparently semicolons aren't needed for the last statement in a block
		# wtf are you smoking, larry wall
		if ($curr{"type"} ne CURLY_CLOSE) {
			#print "$upto $#tokens\n";
			#print Dumper(\%curr)."\n";
			($curr{"type"} eq SEMICOLON) or die "Expecting semicolon/closing brace";
			$upto++;
		}
	}

	return $node_ref;
}

sub parse_varmod {
	# some kind of statement intended to modify a variable

	#print "reading varmod\n";

	# they all start with a var...
	my $var_ref = parse_var();
	my $var_type = $var_ref->{"type"};

	# ...then some kind of operation...
	my %op = %{$tokens[$upto]};
	my $type = $op{"type"};

	my %op2;
	my $type2;

	if ($upto+1 <= $#tokens) {
		%op2 = %{$tokens[$upto+1]}; # the token after the op
		$type2 = $op2{"type"};
	}
	$upto++; # read the op

	my $newvalue_ref;

	if ($type eq EQUALS) {
		# plain old assignment
		# unless we're talking about a hash or array, that is...
		if ($var_type eq NODE_VARIABLE) {
			$newvalue_ref = parse_expr();
		} elsif ($var_type eq NODE_ARRAY) {
			# if there's a parenthesis, parse an array list
			if (defined $type2 && $type2 eq PARENTHESIS_OPEN) {
				$newvalue_ref = parse_array_list();
			} else {
				$newvalue_ref = parse_expr();
			}
		} elsif ($var_type eq NODE_HASH) {
			if (defined $type2 && $type2 eq PARENTHESIS_OPEN) {
				$newvalue_ref = parse_hash_list();
			} else {
				$newvalue_ref = parse_expr();
			}
		}
	} elsif (($type eq INCREMENT) ||
		     ($type eq DECREMENT)) {
		# create an assignment of the form
		# <var> = <var> + 1
		my $one_ref = makeToken(NUMBER);
		$one_ref->{"value"} = 1;

		my $op_ref;
		if ($type eq INCREMENT) {
			$op_ref = makeToken(PLUS);
		} elsif ($type eq DECREMENT) {
			$op_ref = makeToken(MINUS);
		}

		$newvalue_ref = {
			"type" => NODE_EXPRESSION,
			"value" => $op_ref,
			"children" => [$var_ref, $one_ref]
		};
	} elsif (defined $type2 && $type2 eq REASSIGN) {
		# create an assignment of the form
		# <var> = <var> <op> <expr>
		$upto++; # skip reassign
		$newvalue_ref = {
			"type" => NODE_EXPRESSION,
			"value" => \%op,
			"children" => [$var_ref, parse_expr()]
		};
	} else {
		die "i dunno lol";
	}

	#@children = ($var_ref, $newvalue_ref);

	#print "i made a varmod\n";
	my %node = (
		"type" => NODE_ASSIGNMENT,
		"name" => $var_ref,
		"value" => $newvalue_ref
	);
	#print Dumper(\%node)."\n";

	return \%node;
}

sub parse_array_list {
	# read the parenthesis
	$upto++;

	#print "reading array list\n";

	my @children = ();

	# read up to the closing parenthesis
	while ($tokens[$upto]->{"type"} ne PARENTHESIS_CLOSE) {
		push @children, parse_expr();

		# consume comma
		if ($tokens[$upto]->{"type"} eq COMMA) {
			$upto++;
		}
	}

	# consume closing parenthesis
	$upto++;

	my %node = (
		"type" => NODE_ARRAY_LIST,
		"children" => \@children
	);

	return \%node;
}

sub parse_hash_list {
	# read parenthesis
	$upto++;

	#print "reading hash list\n";

	my @children = ();
	# children will be key-value pairs

	while ($tokens[$upto]->{"type"} ne PARENTHESIS_CLOSE) {
		my $key_ref = parse_expr();
		
		# consume =>
		($tokens[$upto]->{"type"} eq POINT) or die "Expecting =>";
		$upto++;

		my $value_ref = parse_expr();

		# consume comma
		if ($tokens[$upto]->{"type"} eq COMMA) {
			$upto++;
		}

		push @children, [$key_ref, $value_ref];
	}

	# consume closing parenthesis
	$upto++;

	my %node = (
		"type" => NODE_HASH_LIST,
		"children" => \@children
	);

	return \%node;
}

sub parse_call {
	# get the name of the call
	my %curr = %{$tokens[$upto]};
	my $name = $curr{"value"};
	#print "parsing call $name\n";
	$upto++;

	my $args_ref;

	# is there an if or something stupid like that?
	%curr = %{$tokens[$upto]};
	if ($curr{"type"} eq WORD && $curr{"value"} eq "if") {
		# parse it as an if statement
		# it's probably some weird "last if" type of thing
		$upto++; # consume if

		$args_ref = [parse_expr()];
	} else {
		# parse arguments
		$args_ref = parse_args();
	}

	# assemble a node
	my %node = (
		"type" => NODE_CALL,
		"name" => $name,
		"children" => $args_ref
	);

	return \%node;
}

sub parse_args {
	# we'll know we're at the end when we hit either:
	# (1) closing parenthesis (assuming there was an opening one)
	# (2) semicolon

	# initialise array of args
	my @args = ();

	# check for parentheses
	my $parentheses = 0;

	my %curr = %{$tokens[$upto]};
	if ($curr{"type"} eq PARENTHESIS_OPEN) {
		$parentheses = 1;
		$upto++;
	}

	if ($curr{"type"} ne COMMA) {
		# nested functions without parentheses are extremely ambiguous!
		# but one thing that's for sure is that if the first token is a comma,
		# it must just be a call to the function with no args.

		my $first = 1;

		while ($upto <= $#tokens) {
			my %curr = %{$tokens[$upto]};
			my %next;

			if ($upto < $#tokens) {
				%next = %{$tokens[$upto+1]};
			}

			if ($curr{"type"} eq PARENTHESIS_CLOSE) {
				# ...were we expecting it?
				if ($parentheses) {
					# consume the closing parenthesis
					$upto++;
					last;
				} else {
					# end anyway, but don't consume anything
					# nested functions, what even
					last;
				}
			} elsif ($curr{"type"} eq SEMICOLON || $curr{"type"} eq CURLY_CLOSE) {
				# don't actually eat the semicolon, leave that to parse_statement
				last;
			} else {
				# must be an argument
				# if it's not the first arg, we need to consume the comma too
				if (!$first) {
					($curr{"type"} eq COMMA) or die "Expecting comma";
					$upto++;
				}
				
				push @args, parse_arg();
			}

			$first = 0;
		}

	}

	# return the arguments (by reference)
	return \@args;
}

sub parse_arg {
	# wtf is an arg
	return parse_expr();
}

sub parse_expr {
	my %curr = %{$tokens[$upto]};

	#print "reading expr, starting with ", $curr{"type"}, "\n";

	my $left_ref;
	
	if ($curr{"type"} eq WORD) { # is it a call?

		$left_ref = parse_call();
	
	} elsif (($curr{"type"} eq SCALAR) ||
		     ($curr{"type"} eq ARRAY) ||
		     ($curr{"type"} eq HASH)) { # is it a variable?
		
		$left_ref = parse_var();

	} elsif (($curr{"type"} eq LOGICAL_NOT) ||
		     ($curr{"type"} eq BIT_NOT) ||
		     ($curr{"type"} eq MINUS)) { # is it a unary operator?
		# ^ yeah, about that... minus can also be a unary operator.
		# negative numbers and such.

		# consuuuuuume the operator
		$upto++;

		$left_ref = parse_expr();

		my %node = (
			"type" => NODE_EXPRESSION,
			"value" => \%curr, # operator
			"children" => [$left_ref]
		);

		return \%node;

	} elsif ($curr{"type"} eq PARENTHESIS_OPEN) { # is it a parenthesis?

		# delicious parentheses
		$upto++;

		$left_ref = parse_expr();

		my %node = (
			"type" => NODE_EXPRESSION,
			"value" => \%curr,
			"children" => [$left_ref]
		);

		# i'm still hungry; eat the right parenthesis as well
		%curr = %{$tokens[$upto]};
		($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expecting closing parenthesis";
		$upto++;

		# new left ref is the contents of the grouping
		# we need to check if this is part of a larger expression!
		$left_ref = \%node;

	} else {
		# default to literal
		$upto++;
		$left_ref = \%curr;
	}

	# check for an operator
	if (defined $tokens[$upto]) {
		my %op = %{$tokens[$upto]};
		my $type = $op{"type"};

		# check for binary operators
		if (($type eq PLUS) ||
			($type eq MINUS) ||
			($type eq MUL) ||
			($type eq DIV) ||
			($type eq MOD) ||
			($type eq POW) ||
			($type eq BIT_OR) ||
			($type eq BIT_AND) ||
			($type eq SHIFT_LEFT) ||
			($type eq SHIFT_RIGHT) ||
			($type eq XOR) ||
			($type eq LOGICAL_AND) ||
			($type eq LOGICAL_OR) ||
			($type eq CONCAT) ||
			($type eq DOUBLE_EQUALS) ||
			($type eq NOT_EQUALS) ||
			($type eq GREATER_THAN) ||
			($type eq GREATER_EQUALS) ||
			($type eq LESS_THAN) ||
			($type eq LESS_EQUALS)) {

			# consume operator
			$upto++;

			my $right_ref = parse_expr();

			my %node = (
				"type" => NODE_EXPRESSION,
				"value" => \%op,
				"children" => [$left_ref, $right_ref]
			);

			return \%node;

		} elsif ($type eq MATCH) {
			# hello regex my old friend...

			# consume =~
			$upto++;

			my %node = (
				"type" => NODE_REGEX,
				"value" => $left_ref
			);

			# is it a regular match, or is there an s in there?
			# TODO: handle s
			%curr = %{$tokens[$upto]};
			if ($curr{"type"} eq WORD) {
				# looks like an s, dammit
				($curr{"value"} eq "s") or die "Expected 's'";

				# consume s
				$upto++;

				my $pattern_ref = $tokens[$upto];
				$upto++;
				my $repl_ref = $tokens[$upto];
				$upto++;

				# check for flags
				my @flags = ();

				%curr = %{$tokens[$upto]};
				if ($curr{"type"} eq WORD) {
					@flags = split //, $curr{"value"};
					$upto++;
				}

				$node{"children"} = [$pattern_ref, $repl_ref, \@flags];
			} else {
				# regular regex match

				my $pattern_ref = $tokens[$upto];
				$upto++;

				$node{"children"} = [$pattern_ref];
			}

			return \%node;
		}
	}

	# just return the left of the expression, nothing else to see here
	return $left_ref;
}

sub parse_var {
	my %curr = %{$tokens[$upto]};
	$upto++;

	my %node = (
		"name" => $curr{"value"}
	);

	if ($curr{"type"} eq SCALAR) {
		$node{"type"} = NODE_VARIABLE;

		# are we indexing an array/hash?
		if ($upto <= $#tokens) {
			my %next = %{$tokens[$upto]};
			if ($next{"type"} eq SQUARE_OPEN) {
				# array indexing
				$upto++;
				$node{"index"} = parse_expr();
				$node{"index_type"} = ARRAY;

				# consume closing bracket
				%next = %{$tokens[$upto]};
				($next{"type"} eq SQUARE_CLOSE) or die "Expecting closing square bracket";
				$upto++;
			} elsif ($next{"type"} eq CURLY_OPEN) {
				# hash indexing
				$upto++;
				$node{"index"} = parse_expr();
				$node{"index_type"} = HASH;

				# consume closing bracket
				%next = %{$tokens[$upto]};
				($next{"type"} eq CURLY_CLOSE) or die "Expecting closing curly bracket";
				$upto++;
			}
		}
		# otherwise it's a plain old scalar

		# if we're not interpolating, add it to the list of variables to be initialised
		my $name = $curr{"value"};
		if (!$interpolating && !grep /^$name$/, @variables) {
			push @variables, $name;
		}

	} elsif ($curr{"type"} eq ARRAY) {
		$node{"type"} = NODE_ARRAY;
	} elsif ($curr{"type"} eq HASH) {
		$node{"type"} = NODE_HASH;
	}

	return \%node;
}

# --== COMPILER ==--

# turn the AST into valid python, how bad can that be?
# ...oh god, why didn't I just use regex in the first place ;_;

# have a global for indentation level
our $indent_level = 0;
use constant INDENT => "  ";

sub op_to_string {
	my $op_ref = shift;
	my $type = $op_ref->{"type"};

	switch ($type) {
		case PLUS			{ return "+" }
		case MINUS			{ return "-" }
		case MUL			{ return "*" }
		case DIV			{ return "/" }
		case MOD			{ return "%" }
		case POW			{ return "**" }
		case CONCAT			{ return "+" }
		case BIT_AND		{ return "&" }
		case BIT_OR			{ return "|" }
		case BIT_NOT		{ return "~" }
		case SHIFT_LEFT		{ return "<<" }
		case SHIFT_RIGHT	{ return ">>" }
		case XOR			{ return "^" }
		case LOGICAL_AND	{ return "and" }
		case LOGICAL_OR		{ return "or" }
		case LOGICAL_NOT	{ return "not" }

		case DOUBLE_EQUALS	{ return "==" }
		case NOT_EQUALS		{ return "!=" }
		case GREATER_THAN	{ return ">" }
		case GREATER_EQUALS { return ">=" }
		case LESS_THAN		{ return "<" }
		case LESS_EQUALS	{ return "<=" }

		else				{ die "Unexpected operator" }
	} 
}

sub compile {
	# argument will just be the root of the AST

	my %node = %{$_[0]};
	my $type = $node{"type"};

	#print "compiling $type\n";

	my $output = "";
	my $indent = INDENT x $indent_level;

	if ($type eq NODE_SECTIONS) {

		# won't somebody *please* think of the children!?
		my @children = @{$node{"children"}};

		# compile them one by one
		#for $statement (@{$node{"children"}}) {
		my @statements = @{$node{"children"}};

		for my $i (0..$#statements) {
			$output .= $indent;
			$output .= compile($statements[$i]);
			if ($i < $#statements) {
				$output .= "\n";
			}
		}

		# was it empty!?
		if (@{$node{"children"}} == 0) {
			$output .= $indent;
			$output .= "pass\n";
		}

	} elsif (($type eq NODE_IF) ||
		     ($type eq NODE_ELSEIF) ||
		     ($type eq NODE_ELSE) ||
		     ($type eq NODE_WHILE) ||
		     ($type eq NODE_FOR_RANGE) ||
		     ($type eq NODE_FOREACH) ||
		     ($type eq NODE_FUNCTION)) { # functions are just elses with a name!

		my $statement_ref = $node{"value"};

		my $block_type;
		if ($type eq NODE_IF) {
			$block_type = "if";
		} elsif ($type eq NODE_ELSEIF) {
			$block_type = "elif";
		} elsif ($type eq NODE_ELSE) {
			$block_type = "else";
		} elsif ($type eq NODE_WHILE) {
			$block_type = "while";
		} elsif ($type eq NODE_FOR_RANGE || $type eq NODE_FOREACH) {
			$block_type = "for";
		}

		if ($type eq NODE_FUNCTION) {
			$output .= "def ";
			$output .= $statement_ref; # this will be a string for functions (the name of the function)
			$output .= "(*_)";
		} elsif ($type eq NODE_ELSE) {
			$output .= $block_type;
		} elsif ($type eq NODE_FOR_RANGE) {
			# value will be the lower and upper bounds of the range
			my $lower_ref = $node{"value"}[0];
			my $upper_ref = $node{"value"}[1];

			# counter variable
			my $var_ref = $node{"name"};

			$output .= "$block_type ";
			$output .= compile($var_ref);
			$output .= " in xrange(";

			# we can skip the lower bound if it's a number that equals zero
			if (!($lower_ref->{"type"} eq NUMBER && $lower_ref->{"value"} == 0)) {
				$output .= compile($lower_ref);
				$output .= ", ";
			}

			# if the upper bound is a number, we can add 1 to it ourselves
			# otherwise let python do it
			if ($upper_ref->{"type"} eq NUMBER) {
				$output .= $upper_ref->{"value"} + 1;
			} else {
				$output .= compile($upper_ref);
				$output .= "+1";
			}
			$output .= ")";
		} elsif ($type eq NODE_FOREACH) {
			# just print the name of the array
			my $var_ref = $node{"name"};
			my $array_ref = $node{"value"};

			$output .= "$block_type ";
			$output .= compile($var_ref);
			$output .= " in ";
			#$output .= $array_ref->{"value"};
			$output .= compile($array_ref);
		} else {
			# is this an assignment?
			if ($statement_ref->{"type"} eq NODE_ASSIGNMENT) {
				my $var_ref = $statement_ref->{"name"};

				# perform first assignment before loop
				$output .= compile($statement_ref);
				$output .= "\n";

				# use variable in condition
				$output .= $indent . "$block_type ";
				$output .= compile($var_ref);
			} elsif ($statement_ref->{"type"} eq NODE_REGEX) { # or a regex match
				$output .= compile($statement_ref);
				$output .= "\n";

				# use _match_ in condition
				$output .= $indent . "$block_type ";
				$output .= "_match_";
			} else {
				$output .= "$block_type ";
				$output .= compile($node{"value"});
			}
		}
		$output .= ":\n";

		$indent_level++;

		# if it's a function, ensure that _ is cast to a list (tuples are immutable)
		if ($type eq NODE_FUNCTION) {
			$output .= $indent . INDENT . "_ = list(_)\n";
		}

		$output .= compile($node{"children"}[0]);

		# is it an assignment?
		# also check whether the statement is actually a hash before continuing
		if (ref($statement_ref) eq "HASH") {
			if ($statement_ref->{"type"} eq NODE_ASSIGNMENT || $statement_ref->{"type"} eq NODE_REGEX) {
				# run the assignment at the end of the loop
				$output .= "\n";
				$output .= $indent . INDENT . compile($statement_ref);
			}
		}

		$indent_level--;

	} elsif ($type eq NODE_FOR_CLASSICAL) {

		# value will be the three parts to the for loop
		my $one_ref = $node{"value"}[0];
		my $two_ref = $node{"value"}[1];
		my $three_ref = $node{"value"}[2];

		# structure like so:
		# <one_ref>
		# while <two_ref>:
		#   <body>
		#   <three_ref>

		$output .= compile($one_ref);
		$output .= "\n";
		$output .= $indent . "while ";
		$output .= compile($two_ref);
		$output .= ":\n";

		$indent_level++;
		$output .= compile($node{"children"}[0]);
		$output .= "\n";
		$output .= $indent . INDENT . compile($three_ref);
		$indent_level--;

	} elsif ($type eq NODE_CALL) {

		# check for special calls
		#my $name = "heisenberg";
		my $name = $node{"name"};
		my @args = @{$node{"children"}};

		# add the anonymous variable to args if none were supplied
		my $anon_ref = {
			"type" => NODE_VARIABLE,
			"name" => "_"
		};

		if (@args == 0) {
			push @args, $anon_ref;
		}

		if ($name eq "print") {
			for my $i (0..$#args) {
				if ($i > 0) { # first line will already have the indent
					$output .= $indent;
				}
				$output .= "sys.stdout.write(_p2p_.string(";
				$output .= compile($args[$i]);
				$output .= ")";
				$output .= ")";
				if ($i < $#args) { # last line won't need a newline
					$output .= "\n";
				}
			}
		} elsif ($name eq "printf") {
			my $format_string = compile($args[0]);

			$output .= "sys.stdout.write(";
			$output .= $format_string;
			$output .= " % (";
			for my $i (1..$#args) {
				$output .= compile($args[$i]);
				if ($i < $#args) {
					$output .= ", ";
				}
			}
			$output .= "))";
		} elsif ($name eq "open") {
			my $file_ref = $args[0];

			# are we reading, writing, or opening a process?
			my $open_string = $args[1]->{"value"};
			if ($open_string =~ /^\s*\|/) {
				# open a process
				die "TODO: processes";
			} else {
				my $flag;
				if ($open_string =~ /^\s*</) {
					# reading
					$flag = "r";
					$open_string =~ s/^\s*<\s*//;
				} elsif ($open_string =~ /^\s*>/) {
					# writing
					$flag = "w";
					$open_string =~ s/^\s*>\s*//;
				}
				# put new open string back into arg for interpolation
				$args[1]->{"value"} = $open_string;

				$output .= $file_ref->{"name"};
				$output .= " = open(";
				$output .= compile($args[1]);
				$output .= ', "';
				$output .= $flag;
				$output .= '")'
			}

		} elsif ($name eq "close") {
			my $file_ref = $args[0];

			# close the file

			$output .= $file_ref->{"name"};
			$output .= ".close()";
		} elsif ($name eq "last" || $name eq "next") {
			if ($name eq "last") {
				$name = "break";
			} elsif ($name eq "next") {
				$name = "continue";
			}
			# is there an if statement child?
			if (@args > 0) {
				$output .= "if ";
				$output .= compile($args[0]);
				$output .= ": ";
			}
			$output .= $name;
		} elsif ($name eq "chomp") {
			# use a function in our custom module
			my $var_ref = $args[0];

			# TODO: handle chomping arrays
			$output .= compile($var_ref);
			$output .= " = _p2p_.chomp(";
			$output .= compile($var_ref);
			$output .= ")";
		} elsif ($name eq "split") {
			# split -> split
			# fancy that...

			# add anonymous variable if only 1 arg
			if (@args == 1) {
				push @args, $anon_ref;
			}

			my $pattern_ref = $args[0];
			my $var_ref = $args[1];

			if ($pattern_ref->{"type"} eq REGEX) {
				# turn into a string and interpolate
				# special case: empty pattern (python doesn't handle this properly)
				if ($pattern_ref->{"value"} eq "") {
					$output .= "list(";
					$output .= compile($var_ref);
					$output .= ")";
				} else {
					$pattern_ref->{"type"} = STRING_INTERPOLATED;
					$output .= "re.split(";
					$output .= compile($pattern_ref);
					$output .= ", ";
					$output .= compile($var_ref);
					$output .= ")";
				}
	 		} else {
				$output .= compile($var_ref);
				$output .= ".split(";
				$output .= compile($pattern_ref);
				$output .= ")";
			}
		} elsif ($name eq "join") {
			my $pattern_ref = $args[0];
			my $var_ref = $args[1];

			$output .= compile($pattern_ref);
			$output .= ".join(";

			if ($var_ref->{"type"} eq NODE_ARRAY) {
				$output .= compile($var_ref);
			} else {
				$output .= "(";
				for my $i (1..$#args) {
					$output .= compile($args[$i]);
					if ($i < $#args) {
						$output .= ", ";
					}
				}
				$output .= ")";
			}

			$output .= ")";
		} elsif ($name eq "push") {
			my $array_ref = $args[0];
			my $var_ref = $args[1];

			$output .= compile($array_ref);
			$output .= ".append(";
			$output .= compile($var_ref);
			$output .= ")";
		} elsif ($name eq "pop") {
			my $array_ref = $args[0];

			$output .= compile($array_ref);
			$output .= ".pop()"
		} elsif ($name eq "unshift") {
			my $array_ref = $args[0];
			my $var_ref = $args[1];

			$output .= compile($array_ref);
			$output .= ".insert(0, ";
			$output .= compile($var_ref);
			$output .= ")";
		} elsif ($name eq "shift") {
			my $array_ref = $args[0];

			$output .= compile($array_ref);
			$output .= ".pop(0)";
		} elsif ($name eq "reverse") {
			my $array_ref = $args[0];

			$output .= compile($array_ref);
			$output .= "[::-1]";
		} elsif ($name eq "keys") {
			my $hash_ref = $args[0];

			$output .= compile($hash_ref);
			$output .= ".keys()";
		} elsif ($name eq "values") {
			my $hash_ref = $args[0];

			$output .= compile($hash_ref);
			$output .= ".values()";
		} elsif ($name eq "sort") {
			# todo: handle fancy comparison stuff (unlikely though)
			$output .= "sorted(map(_p2p_.string, ";
			$output .= compile($args[0]);
			$output .= "))";
		} elsif ($name eq "return") {
			# don't use parentheses
			$output .= "$name ";
			for my $i (0..$#args) {
				$output .= compile($args[$i]);
				if ($i < $#args) {
					$output .= ", ";
				}
			}
		} else {
			# ordinary function call
			$output .= $name;
			$output .= "(";
			for my $i (0..$#args) {
				$output .= compile($args[$i]);
				if ($i < $#args) {
					$output .= ", ";
				}
			}
			$output .= ")";
		}

	} elsif ($type eq STRING) {

		# easy mode
		my $value = $node{"value"};
		$value =~ s/"/\\"/g;
		$output .= '"' . $value . '"';

	} elsif ($type eq STRING_INTERPOLATED) {

		my $value = $node{"value"};
		$value =~ s/"/\\"/g;
		my @chars = split //, $value;

		if (@chars == 0) {
			$output .= '""';
		} else {

			# let's do some shitty mini tokenisation/parsing! yay
			my $i = 0;
			my $tmp = ""; # holds the part of the ordinary string we've read so far
			my $empty = 1; # holds whether we've output something yet
			while ($i < @chars) {
				my $curr = $chars[$i];
				my $next = "";
				if ($i+1 <= $#chars) {
					$next = $chars[$i+1];
				}

				if ($curr eq "\\") {
					if (defined $next && $next eq '$') {
						$tmp .= '$';
						$i += 2;
						next;
					} else {
						$tmp .= $curr;
					}
				} elsif ((($curr eq '$') || ($curr eq '@')) && $next ne "") {
					# oh boy interpolation here we go
					if (!$empty) {
						$output .= " + ";
					} else {
						$empty = 0;
					}

					if (length($tmp) > 0) {
						$output .= '"' . $tmp . '" + ';
						$tmp = "";
					}

					$interpolating = 1;

					# tokenise expression using the global tokeniser
					# so much hax...
					@tokens = tokenise(substr($value, $i, length($value)-$i));

					if ($debug) {
						print "tokens:".Dumper(@tokens)."\n";
					}
					# now parse it
					# it'll stop once it considers the expression is done
					$upto = 0;
					my $tree_ref = parse_var();

					if ($debug) {
						print Dumper($tree_ref)."\n";
					}
					# and compile it
					
					my $str_output = compile($tree_ref);
					$output .= "_p2p_.string(" . $str_output . ")";

					$interpolating = 0;

					# hax to the max
					$i += $last_interpolation_index;
				} else {
					$tmp .= $curr;
				}

				$i++;
			}

			# add tmp if there's something left
			if (length($tmp) > 0) {
				if (!$empty) {
					$output .= " + ";
				}
				$output .= '"' . $tmp . '"';
			}

		}

	} elsif ($type eq NODE_REGEX) {

		# isolated regex (i.e. outside of a condition)

		# do interpolation by switching it to string and recompiling
		my $pattern_ref = $node{"children"}[0];
		$pattern_ref->{"type"} = STRING_INTERPOLATED;
		#$output .= compile($pattern_ref);

		# is it a normal match or a substitution?
		if (@{$node{"children"}} == 1) { # normal match thing
			$output .= "_match_ = re.search(";
			$output .= compile($pattern_ref);
			$output .= ", ";
			$output .= compile($node{"value"}); # var
			$output .= ")";
		} elsif (@{$node{"children"}} == 3) { # substitution
			# read replacement string
			# also do interpolation with weird shit

			my $count = 1; # default count is 1, i.e. only make a single replacement

			my $repl_ref = $node{"children"}[1];
			$repl_ref->{"type"} = STRING_INTERPOLATED;

			my @flags = @{$node{"children"}[2]};
			if (grep /^g$/, @flags) {
				$count = 0;
			}

			$output .= compile($node{"value"}); # var
			$output .= " = re.sub(";
			$output .= compile($pattern_ref);
			$output .= ", ";
			$output .= compile($repl_ref);
			$output .= ", ";
			$output .= compile($node{"value"}); # var again
			$output .= ", ";
			$output .= $count;
			if (grep /^i$/, @flags) {
				$output .= ", re.I";
			}
			$output .= ")";
		}

	} elsif ($type eq NUMBER) {

		$output .= $node{"value"};

	} elsif ($type eq COMMENT) {

		$output .= $indent;
		$output .= "#";
		$output .= $node{"value"};
		#$output .= "\n";

	} elsif ($type eq NEWLINE) {

		# do nothing... the newline will be inserted automagically by compiling sections

	} elsif ($type eq NODE_VARIABLE) {

		# if the first char is #, it's actually last index of array
		my $name = $node{"name"};

		# also check if the name is numeric, since it's then a bloody regex thing (except for 0)

		if (substr($name, 0, 1) eq "#") {
			$name = substr($name, 1, length($name));
			$output .= "len(";
			$output .= $name;
			$output .= ")-1";
		} elsif ($name =~ /^[0-9]+$/) {
			if ($name == "0") {
				# name of current script
				$output .= "sys.argv[0]";
			} else {
				# regex match index
				$output .= "_match_.group(" . $name . ")";
			}
		} else {
			if (defined $node{"index"}) {
				$output .= $node{"name"};
				$output .= "[";

				# if this is an array, convert index to number

				if ($node{"index_type"} eq ARRAY) {
					my $type = $node{"index"}->{"type"};
					if ($type ne NUMBER && $type ne NODE_EXPRESSION) {
						$output .= "int(_p2p_.num(" . compile($node{"index"}) . "))";
					} else {
						$output .= compile($node{"index"});
					}
				} else {
					$output .= compile($node{"index"});
				}

				$output .= "]";
			} else {
				$output .= $node{"name"};
			}
		}

	} elsif ($type eq NODE_ARRAY) {

		if ($interpolating) {
			$output .= '" ".join(map(str, ';
			$output .= $node{"name"};
			$output .= '))';
		} else {
			# use the name of the array if there aren't exceptional circumstances
			$output .= $node{"name"};
		}

	} elsif ($type eq NODE_HASH) {

		# default to the name of the hash
		$output .= $node{"name"};

	} elsif ($type eq NODE_ARRAY_LIST) {

		my @items = @{$node{"children"}};

		$output .= "[";
		for my $i (0..$#items) {
			$output .= compile($items[$i]);
			if ($i < $#items) {
				$output .= ", ";
			}
		}
		$output .= "]";

	} elsif ($type eq NODE_HASH_LIST) {

		my @items = @{$node{"children"}};

		$output .= "{";
		for my $i (0..$#items) {
			$output .= compile($items[$i]->[0]); # key
			$output .= ": ";
			$output .= compile($items[$i]->[1]); # value
			if ($i < $#items) {
				$output .= ", ";
			}
		}
		$output .= "}";

	} elsif ($type eq NODE_ASSIGNMENT) {

		my $left_ref = $node{"name"};
		my $right_ref = $node{"value"};

		# what if we're trying to assign to the index of a hash that doesn't exist yet?
		# that would be a damn shame
		if ($left_ref->{"type"} eq NODE_VARIABLE &&
			exists $left_ref->{"index_type"} &&
			$left_ref->{"index_type"} eq HASH) {
			my $name = $left_ref->{"name"};
			$output .= "if \"$name\" not in vars() or type($name) not in (dict, defaultdict): $name = defaultdict(str)\n";
			$output .= $indent;
		}
		$output .= compile($left_ref);
		$output .= " = ";

		# special case: assignment to an array of a file handle
		if ($left_ref->{"type"} eq NODE_ARRAY && $right_ref->{"type"} eq HANDLE_INPUT) {
			# change the ref type to HANDLE_INPUT_MULTILINE
			# yay context!
			$right_ref->{"type"} = HANDLE_INPUT_MULTILINE;
		}
		$output .= compile($right_ref);

	} elsif ($type eq NODE_EXPRESSION) {

		# oh boy, shit gets weird here...
		# hands up who likes an excessive number of parentheses?

		my @operands = @{$node{"children"}};

		# is it a grouping?
		if ($node{"value"}{"type"} eq PARENTHESIS_CLOSE) {
			# daaaamn this is hax.
			$output .= "(";
			$output .= compile($operands[0]);
			$output .= ")";
		} else {

			my $optype = $node{"value"}->{"type"};
			my $opstring = op_to_string($node{"value"});

			# tells us if it's a string comparator or not
			# haxville, population: me
			my $string_comparator = (defined $node{"value"}->{"value"});

			if (@operands == 2) {

				# binary operator
				# ensure string operation operands are strings
				# arithmetic operation operands are numbers
				# etc.

				my $left = compile($operands[0]);
				my $right = compile($operands[1]);

				my $type0 = $operands[0]->{"type"};
				my $type1 = $operands[1]->{"type"};

				if (($optype eq CONCAT) ||
					($string_comparator && (
					($optype eq GREATER_THAN) ||
					($optype eq GREATER_EQUALS) ||
					($optype eq LESS_THAN) ||
					($optype eq LESS_EQUALS) ||
					($optype eq DOUBLE_EQUALS) ||
					($optype eq NOT_EQUALS) ||
					($optype eq CONCAT)))) {
					# string ops

					if ($type0 ne STRING) {
						$left = "_p2p_.string(" . $left . ")";
					}
					if ($type1 ne STRING) {
						$right = "_p2p_.string(" . $right . ")";
					}
				} elsif (($optype eq LOGICAL_AND) ||
					    ($optype eq LOGICAL_OR) ||
					    ($optype eq LOGICAL_NOT)) {
					# nothing special to be done here
				} else {
					# arithmetic

					if ($type0 ne NUMBER && $type0 ne NODE_EXPRESSION) {
						$left = "_p2p_.num(" . $left . ")";
					}
					if ($type1 ne NUMBER && $type1 ne NODE_EXPRESSION) {
						$right = "_p2p_.num(" . $right . ")";
					}
				}

				$output .= $left;
				$output .= " $opstring ";
				$output .= $right;

			} elsif (@operands == 1) {
				# unary operator
				$output .= "$opstring";
				$output .= compile($operands[0]);
			} else {
				die "Unexpected number of operands";
			}

		}

	} elsif ($type eq HANDLE_INPUT || $type eq HANDLE_INPUT_MULTILINE) {

		my $handle = $node{"value"};
		my $name;

		# first special case: empty
		if ($handle eq "") {
			$output .= "_input_.readline()";
		} else {
			# special case: STDIN
			if ($handle eq "STDIN") {
				$name = "sys.stdin";
			} else {
				$name = $handle;
			}

			$output .= "$name.";

			if ($type eq HANDLE_INPUT) {
				$output .= "readline";
			} elsif ($type eq HANDLE_INPUT_MULTILINE) {
				$output .= "readlines";
			}

			$output .= "()";
		}

	} else {

		die "Unable to compile $type";

	}

	return $output;
}

# --== MAIN STUFF ==--

# create list of files from arguments
my @files = @ARGV;
# if it's empty, add stdin
if (@ARGV == 0) {
	push @files, "-";
}

foreach my $file (@files) {

	open(F, "< $file");

	my $data = "";
	while (<F>) {
		$data .= $_;
	}

	if ($debug) {
		print "\n", "-" x 50, "\n";
	}

	# initialise parser shiz
	@tokens = tokenise($data);
	$upto = 0;

	if ($debug) {
		print "TOKENISING\n\n";
		print Dumper(\@tokens);
		print "\n", "-" x 50, "\n";
	}

	my $tree_ref = parse();

	if ($debug) {
		print "PARSING\n\n";
		print Dumper($tree_ref);
		print "\n", "-" x 50, "\n";
	}

	#next;

	if ($debug) {
		print "COMPILING\n\n";
	}

	# top stuff
	my $output = "#!/usr/bin/python2.7 -u\n";
	$output .= "from collections import defaultdict\n";
	$output .= "import fileinput\n";
	$output .= "import re\n";
	$output .= "import sys\n";
	$output .= "import perl2python as _p2p_\n";
	$output .= "ARGV = sys.argv[1:]\n";
	$output .= "_input_ = fileinput.input()\n";
	$output .= "\n";

	# initialise variables
	# add the anonymous variable!
	if (!grep /^_$/, @variables) {
		push @variables, "_";
	}
	$output .= join ", ", sort @variables;
	$output .= " = ";
	for (my $i = 0; $i <= $#variables; $i++) {
		$output .= '""';
		if ($i < $#variables) {
			$output .= ", ";
		}
	}
	$output .= "\n\n";

	# actual code
	$output .= compile($tree_ref) . "\n";

	print $output;
	print "\n";
}