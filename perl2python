#!/usr/bin/perl -w

use Data::Dumper; # TODO: remove this at some point
use JSON qw( encode_json );
use Switch;

# george caley presents:
# perl2python
# a COMP2041 assignment

# --== LEXER ==--

# token types
use constant TOKENS => qw(
	COMMENT
	WORD
	SCALAR
	STRING
	NUMBER
	SEMICOLON
	EQUALS DOUBLE_EQUALS POINT MATCH
	GREATER_THAN GREATER_EQUALS LESS_THAN LESS_EQUALS
	NOT_EQUALS LOGICAL_NOT
	SHIFT_LEFT SHIFT_RIGHT
	BIT_OR BIT_AND LOGICAL_OR LOGICAL_AND
	XOR BIT_NOT
	PARENTHESIS_OPEN PARENTHESIS_CLOSE
	SQUARE_OPEN SQUARE_CLOSE
	CURLY_OPEN CURLY_CLOSE
	COMMA
	PLUS INCREMENT
	MINUS DECREMENT
	MUL POW
	DIV
	CONCAT
	REASSIGN
	RANGE
);
# 'reassign' is a special token that can succeed operations
# just a hacky way of dealing with +=, -=, *=, &=, etc.

# single char token mappings
# this will hopefully clean up the lexer code a bit
# anything slightly less trivial (e.g. =, which is special because we need to test ==) 
# will need its own code
%singleCharTokens = (
	";" => SEMICOLON,
	"(" => PARENTHESIS_OPEN,
	")" => PARENTHESIS_CLOSE,
	"[" => SQUARE_OPEN,
	"]" => SQUARE_CLOSE,
	"{" => CURLY_OPEN,
	"}" => CURLY_CLOSE,
	"," => COMMA,
	"/" => DIV
);

# tokeniser states
use constant STATES => qw(
	STATE_IDLE
	STATE_COMMENT
	STATE_WORD
	STATE_SCALAR
	STATE_ARRAY
	STATE_HASH
	STATE_STRING
	STATE_NUMBER
);

# tokens are stored as hashes of type and value

sub makeToken {
	my $type = shift;

	my $token = {};
	$token->{"type"} = $type;

	my $value = shift;
	if (defined $value) {
		$token->{"value"} = $value;
	}

	#print "making token ", %$token, "\n";

	return $token;
}

sub tokenise {
	my $data = shift;

	# data is just the text from the python file
	# it's now our job to chop it up into tokens
	# yay......

	# add newline to data (makes detecting the end of the last line easier)
	$data .= "\n";
	my @chars = split(//, $data);

	# initialise state machine
	my $state = STATE_IDLE;

	# initialise token array
	my @tokens = ();

	# here is a string to store token value
	my $value = "";

	# initialise current char counter
	my $i = 0;

	while ($i < @chars) {

		my $curr = $chars[$i]; # current char
		my $next = $chars[$i+1]; # next char
		my $next2 = $chars[$i+2]; # next *next* char!

		my $token;

		if ($state eq STATE_IDLE) {
			if (defined $singleCharTokens{$curr}) {
				# use a single char token mapping
				push @tokens, makeToken($singleCharTokens{$curr});
				# remain in the idle state
			} elsif ($curr eq "#") {
				# start reading comment
				$state = STATE_COMMENT;
			} elsif ($curr eq "=") {
				# is it double equals?
				if ($next eq "=") {
					$token = makeToken(DOUBLE_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(POINT);
					$i++;
				} elsif ($next eq "~") {
					$token = makeToken(MATCH);
					$i++;
				} else {
					$token = makeToken(EQUALS);
				}

				push @tokens, $token;
			} elsif ($curr eq ">") {
				if ($next eq "=") {
					$token = makeToken(GREATER_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(SHIFT_RIGHT);
					$i++;
				} else {
					$token = makeToken(GREATER_THAN);
				}

				push @tokens, $token;
			} elsif ($curr eq "<") {
				if ($next eq "=") {
					$token = makeToken(LESS_EQUALS);
					$i++;
				} elsif ($next eq ">") {
					$token = makeToken(SHIFT_LEFT);
					$i++;
				} else {
					$token = makeToken(LESS_THAN);
				}

				push @tokens, $token;
			} elsif ($curr eq "!") {
				if ($next eq "=") {
					$token = makeToken(NOT_EQUALS);
					$i++;
				} else {
					$token = makeToken(LOGICAL_NOT);
				}

				push @tokens, $token;
			} elsif ($curr eq "&") {
				if ($next eq "&") {
					push @tokens, makeToken(LOGICAL_AND);
					$i++;
				} else {
					push @tokens, makeToken(BIT_AND);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "|") {
				if ($next eq "|") {
					push @tokens, makeToken(LOGICAL_OR);
					$i++;
				} else {
					push @tokens, makeToken(BIT_OR);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "*") {
				# is it pow?
				if ($next eq "*") {
					push @tokens, makeToken(POW);
					$i++;

					if ($next2 eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				} else {
					push @tokens, makeToken(MUL);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "+") {
				# is it increment?
				if ($next eq "+") {
					push @tokens, makeToken(INCREMENT);
					$i++;
				} else {
					push @tokens, makeToken(PLUS);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "-") {
				# is it decrement?
				if ($next eq "-") {
					push @tokens, makeToken(DECREMENT);
					$i++;
				} else {
					push @tokens, makeToken(MINUS);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq "^") {
				push @tokens, makeToken(XOR);
				if ($next eq "=") {
					push @tokens, makeToken(REASSIGN);
					$i++;
				}
			} elsif ($curr eq "~") {
				push @tokens, makeToken(BIT_NOT);
				if ($next eq "=") {
					push @tokens, makeToken(REASSIGN);
					$i++;
				}
			} elsif ($curr eq ".") {
				if ($next eq ".") {
					push @tokens, makeToken(RANGE);
					$i++;
				} else {
					push @tokens, makeToken(CONCAT);
					if ($next eq "=") {
						push @tokens, makeToken(REASSIGN);
						$i++;
					}
				}
			} elsif ($curr eq '"' || $curr eq "'") {
				# start reading string
				$state = STATE_STRING;
                $separator = $curr;
			} elsif ($curr eq "\$") {
				# start reading scalar
				$state = STATE_SCALAR;
			} elsif ($curr eq "@") {
				# start reading array
				$state = STATE_ARRAY;
			} elsif ($curr eq "%") {
				# start reading hash
				$state = STATE_HASH;
			} elsif ($curr =~ /[A-Za-z_]/) {
				# start reading a word (stuff like keywords, function names, etc.)
				$state = STATE_WORD;
				next;
				#$value .= $curr;
			} elsif ($curr =~ /[0-9]/) {
				# start reading number
				$state = STATE_NUMBER;
				next;
				#$value .= $curr;
			}
		} elsif ($state eq STATE_COMMENT) {
			if ($curr eq "\n") {
				# newline! end of comment
				push @tokens, makeToken(COMMENT, $value);

				$state = STATE_IDLE;
				$value = "";
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_STRING) {
			# keep reading until we hit the end quote
			if ($curr eq $separator) {
				# we're done
				push @tokens, makeToken(STRING, $value);

				$state = STATE_IDLE;
				$value = "";
			} elsif ($curr eq "\\") {
				# is it a backslash followed by a quote?
				if ($next eq $separator) {
                    # consume just the quote
					$value .= $next;
					$i++;
                } elsif ($next eq "\\") {
                    # consume both backslashes
                    $value .= $curr;
                    $value .= $next;
                    $i++;
				} else {
                    # consume it like normal
                    $value .= $curr;
                }
			} else {
				# consume char
				$value .= $curr;
			}
		} elsif ($state eq STATE_SCALAR || $state eq STATE_ARRAY || $state eq STATE_HASH) {
			# consume char
			$value .= $curr;

			# keep reading until we hit something unusual
			if (!($next =~ /[A-Za-z0-9_]/)) {
				# end of name
				if ($state eq STATE_SCALAR) {
					$type = SCALAR;
				} elsif ($state eq STATE_ARRAY) {
					$type = ARRAY;
				} elsif ($state eq STATE_HASH) {
					$type = HASH;
				}

				push @tokens, makeToken($type, $value);

				$state = STATE_IDLE;
				$value = "";
			}
		} elsif ($state eq STATE_WORD) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[A-Za-z0-9_]/)) {
				# end of function name/loop/something like that
				# check for logical operators like and, or, not
				if ($value eq "and") {
					push @tokens, makeToken(LOGICAL_AND);
				} elsif ($value eq "or") {
					push @tokens, makeToken(LOGICAL_OR);
				} elsif ($value eq "not") {
					push @tokens, makeToken(LOGICAL_NOT);
				} else {
					push @tokens, makeToken(WORD, $value);
				}

				$state = STATE_IDLE;
				$value = "";
			}
		} elsif ($state eq STATE_NUMBER) {
			# consume char
			$value .= $curr;

			if (!($next =~ /[0-9]/)) {
				# end of number
				push @tokens, makeToken(NUMBER, $value);

				$state = STATE_IDLE;
				$value = "";
			}
		}

		$i++;

	}

	return @tokens;

}

# --== PARSER ==--

use constant AST_NODES => qw(
	NODE_STATEMENTS
	NODE_COMMENT
	NODE_ASSIGNMENT
	NODE_EXPRESSION
	NODE_CALL
	NODE_VARIABLE
	NODE_ARRAY
	NODE_HASH

	NODE_BLOCK
	NODE_IF
	NODE_ELSEIF
	NODE_ELSE
	NODE_WHILE
	NODE_FOR
	NODE_FOREACH
	NODE_FOR_RANGE

	NODE_SECTIONS
);

# everything here is basically self explanatory (I hope!)
# all nodes have a type
# for container nodes/other special stuff, it'll be one of the above nodes
# for more simple stuff that doesn't warrant translation, it'll be the same types as tokens

# some things have names
# e.g. for variables, this is the name of the variable (duh)
# for assignments, this is the variable that the result is stored in (maybe not so 'duh')
# container nodes also have children

# conditionals/loops store the condition within value, and the block (single child) within children

# the parser operates on a few global variables
# the token array and the current token counter
@tokens = ();
$upto = 0;

sub parse {
	#my $statements_ref = parse_statements();
	my $sections_ref = parse_sections();

	my %node = (
		"type" => NODE_SECTIONS,
		"children" => $sections_ref
	);

	return \%node;
}

# this handles 'if', 'elsif' and 'while', since they're basically all the same thing
sub parse_if {
	# consume the type
	my %curr = %{$tokens[$upto]};
	my $if_type = $curr{"value"};
	$upto++;

	# parse the condition, but skip parentheses
	%curr = %{$tokens[$upto]};
	($curr{"type"} eq PARENTHESIS_OPEN) or die "Expecting opening parenthesis";
	$upto++;

	my $condition_ref = parse_expr();

	%curr = %{$tokens[$upto]};
	($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expecting closing parenthesis";
	$upto++;

	# parse the block
	my $block_ref = parse_block();

	my %node = (
		"value" => $condition_ref,
		"children" => [$block_ref]
	);

	if ($if_type eq "if") {
		$node{"type"} = NODE_IF;
	} elsif ($if_type eq "elsif") {
		$node{"type"} = NODE_ELSEIF;
	} elsif ($if_type eq "while") {
		$node{"type"} = NODE_WHILE;
	}

	return \%node;
}

sub parse_else {
	# consume the 'else'
	$upto++;

	# parse the block
	my $block_ref = parse_block();

	my %node = (
		"type" => NODE_ELSE,
		"children" => [$block_ref]
	);

	return \%node;
}

sub parse_for {
	# consume the 'for' and its type
	my %curr = %{$tokens[$upto]};
	my $for_type = $curr{"value"};
	$upto++;

	my %node;

	# several types we have to worry about:
	# (1) for $i ($j..$k)
	# (2) for ($j..$k) (with the anonymous variable)
	# (3) for $i (@array)
	# (4) for (@array) (with the anonymous variable)
	# (5) for (statement; expression; statement)
	# types 1-2 => for i in xrange(j, k)
	# types 3-4 => for i in array
	# type 5 => statement / while expression: / <block> / statement

	# read the first token
	%curr = %{$tokens[$upto]};
	$upto++;

	# is it a variable?
	if ($curr{"type"} eq SCALAR) {
		# so it's either type 1 or 3
		# consume the parenthesis
		%curr = %{$tokens[$upto]};
		$upto++;
		($curr{"type"} eq PARENTHESIS_OPEN) or die "Expected opening parenthesis";

		# if it's an array, it's type 3
		# otherwise type 1
		%curr = %{$tokens[$upto]};

		if ($curr{"type"} eq ARRAY) {
			# consume array token
			$upto++;

			%node = (
				"type" => NODE_FOREACH,
				"value" => \%curr
			);
		} else {
			# parse expressions
			my $left_ref = parse_expr();

			# consume range token (..)
			%curr = %{$tokens[$upto]};
			$upto++;
			($curr{"type"} eq RANGE) or die "Expecting range symbol (..)";

			my $right_ref = parse_expr();

			%node = (
				"type" => NODE_FOR_RANGE,
				"value" => [$left_ref, $right_ref]
			);
		}

		# consume the closing one too
		%curr = %{$tokens[$upto]};
		$upto++;
		($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expected closing parenthesis";
	} else {

		die "wat";

	}
}

sub parse_block {
	# can either be empty (a semicolon), a single line (another block), or {something in here}

	print "reading block\n";

	my %curr = %{$tokens[$upto]};
	my $type = $curr{"type"};

	my $children = [];

	if ($type eq SEMICOLON) {
		# nothing to do here!
		# except consume it, of course.
		$upto++;
	} elsif ($type eq CURLY_OPEN) {
		# consume opening brace
		$upto++;

		#push @children, parse_sections();
		$children = parse_sections();

		# consume the closing brace
		%curr = %{$tokens[$upto]};
		($curr{"type"} eq CURLY_CLOSE) or die "Expecting closing brace";
		$upto++;
	} else {
		# a single section!? wtf
		#push @children, parse_sections();
		$children = parse_sections();
	}

	my %node = (
		"type" => NODE_SECTIONS,
		"children" => $children
	);

	return \%node;
}

sub parse_sections {
	# parse numerous sections

	my @sections = ();

	while ($upto <= $#tokens) {

		my %curr = %{$tokens[$upto]};
		my $type = $curr{"type"};

		# are we looking at a conditional, loop, or statement?
		if ($type eq WORD) {
			# could be...
			$name = $curr{"value"};
			if (($name eq "for") ||
				($name eq "foreach")) {
				# for loop
				push @sections, parse_for();
			} elsif ($name eq "while") {
				# while loop
				push @sections, parse_if();
			} elsif ($name eq "if") {
				# if conditional
				#die "TODO: if statements";
				push @sections, parse_if();
			} elsif ($name eq "elsif") {
				# else if
				push @sections, parse_if();
			} elsif ($name eq "else") {
				# else
				push @sections, parse_else();
			} else {
				# suppose it's none of the above then
				# parse as a statement
				push @sections, parse_statement();
			}
		} elsif ($type eq CURLY_CLOSE) {
			# end of block!
			last;
		} else {
			# parse as a statement. what else could it be?
			push @sections, parse_statement();
		}

	}

	return \@sections;
}

sub parse_statements {
	# parse numerous statements
	# TODO: if/while loops

	my @statements = ();

	while ($upto <= $#tokens) {
		push @statements, parse_statement();
	}

	return \@statements;
}

sub parse_statement {
	# parse a single statement

	my %curr = %{$tokens[$upto]};
	my $type = $curr{"type"};

	my $node_ref;

	if ($type eq COMMENT) {
		$node_ref = \%curr;
		$upto++;
	} elsif ($type eq SCALAR) {
		# varmod
		$node_ref = parse_varmod();
	} else {
		# default to expression
		#$node_ref = parse_call();
		$node_ref = parse_expr();
	}

	# consume semicolon
	# om nom nom
	if ($upto <= $#tokens && !($type eq COMMENT)) {
		%curr = %{$tokens[$upto]};
		($curr{"type"} eq SEMICOLON) or die "Expecting semicolon";
		$upto++;
	}

	return $node_ref;
}

sub parse_varmod {
	# some kind of statement intended to modify a variable

	print "reading varmod\n";

	# they all start with a var...
	my $var_ref = parse_var();

	# ...then some kind of operation...
	my %op = %{$tokens[$upto]};
	my %op2 = %{$tokens[$upto+1]}; # the token after the op
	my $type = $op{"type"};
	my $type2 = $op2{"type"};
	$upto++; # read the op

	my $newvalue_ref;

	if ($type eq EQUALS) {
		# plain old assignment
		$newvalue_ref = parse_expr();
	} elsif (($type eq INCREMENT) ||
		     ($type eq DECREMENT)) {
		# create an assignment of the form
		# <var> = <var> + 1
		$one_ref = makeToken(NUMBER);
		$one_ref->{"value"} = 1;

		my $op_ref;
		if ($type eq INCREMENT) {
			$op_ref = makeToken(PLUS);
		} elsif ($type eq DECREMENT) {
			$op_ref = makeToken(MINUS);
		}

		$newvalue_ref = {
			"type" => NODE_EXPRESSION,
			"value" => $op_ref,
			"children" => [$var_ref, $one_ref]
		};
	} elsif ($type2 eq REASSIGN) {
		# create an assignment of the form
		# <var> = <var> <op> <expr>
		$upto++; # skip reassign
		$newvalue_ref = {
			"type" => NODE_EXPRESSION,
			"value" => \%op,
			"children" => [$var_ref, parse_expr()]
		};
	} else {
		die "i dunno lol";
	}

	#@children = ($var_ref, $newvalue_ref);

	my %node = (
		"type" => NODE_ASSIGNMENT,
		"name" => $var_ref,
		"value" => $newvalue_ref
	);

	return \%node;
}

sub parse_call {
	# get the name of the call
	my %curr = %{$tokens[$upto]};
	my $name = $curr{"value"};
	print "parsing call $name\n";
	$upto++;

	# parse arguments
	my $args_ref = parse_args();

	# assemble a node
	my %node = (
		"type" => NODE_CALL,
		"name" => $name,
		"children" => $args_ref
	);

	return \%node;
}

sub parse_args {
	# we'll know we're at the end when we hit either:
	# (1) closing parenthesis (assuming there was an opening one)
	# (2) semicolon

	# initialise array of args
	my @args = ();

	# check for parentheses
	my $parentheses = 0;

	my %curr = %{$tokens[$upto]};
	if ($curr{"type"} eq PARENTHESIS_OPEN) {
		$parentheses = 1;
		$upto++;
	}

	my $first = 1;

	while ($upto <= $#tokens) {
		my %curr = %{$tokens[$upto]};
		my %next;

		if ($upto < $#tokens) {
			%next = %{$tokens[$upto+1]};
		} else {
			undef %next;
		}

		if ($curr{"type"} eq PARENTHESIS_CLOSE) {
			# ...were we expecting it?
			if ($parentheses) {
				# consume the closing parenthesis
				$upto++;
				last;
			} else {
				# end anyway, but don't consume anything
				# nested functions, what even
				last;
			}
		} elsif ($curr{"type"} eq SEMICOLON) {
			# don't actually eat the semicolon, leave that to parse_statement
			last;
		} else {
			# must be an argument
			# if it's not the first arg, we need to consume the comma too
			if (!$first) {
				($curr{"type"} eq COMMA) or die "Expecting comma";
				$upto++;
			}
			
			push @args, parse_arg();
		}

		$first = 0;
	}

	# return the arguments (by reference)
	return \@args;
}

sub parse_arg {
	# wtf is an arg
	return parse_expr();
}

sub parse_expr {
	my %curr = %{$tokens[$upto]};

	print "reading expr, starting with ", $curr{"type"}, "\n";

	my $left_ref;
	
	if ($curr{"type"} eq WORD) { # is it a call?

		$left_ref = parse_call();
	
	} elsif (($curr{"type"} eq SCALAR) ||
		     ($curr{"type"} eq ARRAY) ||
		     ($curr{"type"} eq HASH)) { # is it a variable?
		
		$left_ref = parse_var();

	} elsif (($curr{"type"} eq LOGICAL_NOT) ||
		     ($curr{"type"} eq BIT_NOT)) { # is it a unary operator?

		# consuuuuuume the operator
		$upto++;

		$left_ref = parse_expr();

		my %node = (
			"type" => NODE_EXPRESSION,
			"value" => \%curr, # operator
			"children" => [$left_ref]
		);

		return \%node;

	} elsif ($curr{"type"} eq PARENTHESIS_OPEN) { # is it a parenthesis?

		# delicious parentheses
		$upto++;

		$left_ref = parse_expr();

		my %node = (
			"type" => NODE_EXPRESSION,
			"value" => \%curr,
			"children" => [$left_ref]
		);

		# i'm still hungry; eat the right parenthesis as well
		%curr = %{$tokens[$upto]};
		($curr{"type"} eq PARENTHESIS_CLOSE) or die "Expecting closing parenthesis";
		$upto++;

		# new left ref is the contents of the grouping
		# we need to check if this is part of a larger expression!
		$left_ref = \%node;

	} else {
		# default to literal
		$upto++;
		$left_ref = \%curr;
	}

	# check for an operator
	my %op = %{$tokens[$upto]};
	my $type = $op{"type"};

	# check for binary operators
	if (($type eq PLUS) ||
		($type eq MINUS) ||
		($type eq MUL) ||
		($type eq DIV) ||
		($type eq POW) ||
		($type eq BIT_OR) ||
		($type eq BIT_AND) ||
		($type eq XOR) ||
		($type eq LOGICAL_AND) ||
		($type eq LOGICAL_OR) ||
		($type eq CONCAT) ||
		($type eq DOUBLE_EQUALS) ||
		($type eq NOT_EQUALS) ||
		($type eq GREATER_THAN) ||
		($type eq GREATER_EQUALS) ||
		($type eq LESS_THAN) ||
		($type eq LESS_EQUALS)) {

		# consume operator
		$upto++;

		my $right_ref = parse_expr();

		my %node = (
			"type" => NODE_EXPRESSION,
			"value" => \%op,
			"children" => [$left_ref, $right_ref]
		);

		return \%node;

	} else {
		# just return the left of the expression, nothing else to see here
		return $left_ref;
	}
}

sub parse_var {
	my %curr = %{$tokens[$upto]};
	$upto++;

	my %node = (
		"name" => $curr{"value"}
	);

	if ($curr{"type"} eq SCALAR) {
		$node{"type"} = NODE_VARIABLE;

		# are we indexing an array/hash?
		my %next = %{$tokens[$upto]};
		if ($next{"type"} eq SQUARE_OPEN) {
			# array indexing
			$upto++;
			$node{"index"} = parse_expr();

			# consume closing bracket
			%next = %{$tokens[$upto]};
			($next{"type"} eq SQUARE_CLOSE) or die "Expecting closing square bracket";
			$upto++;
		} elsif ($next{"type"} eq CURLY_OPEN) {
			# hash indexing
			$upto++;
			$node{"index"} = parse_expr();

			# consume closing bracket
			%next = %{$tokens[$upto]};
			($next{"type"} eq CURLY_CLOSE) or die "Expecting closing curly bracket";
			$upto++;
		}
		# otherwise it's a plain old scalar
	} elsif ($curr{"type"} eq ARRAY) {
		$node{"type"} = NODE_ARRAY;
	} elsif ($curr{"type"} eq HASH) {
		$node{"type"} = NODE_HASH;
	}

	return \%node;
}

# --== COMPILER ==--

# turn the AST into valid python, how bad can that be?
# ...oh god, why didn't I just use regex in the first place ;_;

# have a global for indentation level
$indent_level = 0;
use constant INDENT => "  ";

sub op_to_string {
	my $op_ref = shift;
	my $type = $op_ref->{"type"};

	switch ($type) {
		case PLUS			{ return "+" }
		case MINUS			{ return "-" }
		case MUL			{ return "*" }
		case DIV			{ return "/" }
		case POW			{ return "**" }
		case CONCAT			{ return "+" }
		case BIT_AND		{ return "&" }
		case BIT_OR			{ return "|" }
		case BIT_NOT		{ return "~" }
		case XOR			{ return "^" }
		case LOGICAL_AND	{ return "and" }
		case LOGICAL_OR		{ return "or" }
		case LOGICAL_NOT	{ return "not" }

		case DOUBLE_EQUALS	{ return "==" }
		case NOT_EQUALS		{ return "!=" }
		case GREATER_THAN	{ return ">" }
		case GREATER_EQUALS { return ">=" }
		case LESS_THAN		{ return "<" }
		case LESS_EQUALS	{ return "<=" }

		else				{ die "Unexpected operator" }
	} 
}

sub compile {
	# argument will just be the root of the AST

	my %node = %{$_[0]};
	my $type = $node{"type"};

	print "compiling $type\n";

	my $output = "";
	my $indent = INDENT x $indent_level;

	if ($type eq NODE_SECTIONS) {

		# won't somebody *please* think of the children!?
		my @children = @{$node{"children"}};

		# compile them one by one
		#for $statement (@{$node{"children"}}) {
		my @statements = @{$node{"children"}};

		for $i (0..$#statements) {
			$output .= $indent;
			$output .= compile($statements[$i]);
			if ($i < $#statements) {
				$output .= "\n";
			}
		}

		# was it empty!?
		if (@{$node{"children"}} == 0) {
			$output .= $indent;
			$output .= "pass\n";
		}

	} elsif (($type eq NODE_IF) ||
		     ($type eq NODE_ELSEIF) ||
		     ($type eq NODE_ELSE) ||
		     ($type eq NODE_WHILE)) {

		# pre-existing indent level
		#$output .= "if ";
		my $block_type;
		if ($type eq NODE_IF) {
			$block_type = "if";
		} elsif ($type eq NODE_ELSEIF) {
			$block_type = "elif";
		} elsif ($type eq NODE_ELSE) {
			$block_type = "else";
		} elsif ($type eq NODE_WHILE) {
			$block_type = "while";
		}

		if ($type eq NODE_ELSE) {
			$output .= $block_type;
		} else {
			$output .= "$block_type ";
			$output .= compile($node{"value"});
		}
		$output .= ":\n";

		$indent_level++;
		$output .= compile($node{"children"}[0]);
		$indent_level--;

	} elsif ($type eq NODE_CALL) {

		# check for special calls
		#my $name = "heisenberg";
		my $name = $node{"name"};
		my @args = @{$node{"children"}};

		if ($name eq "print") {
			for $i (0..$#args) {
				if ($i > 0) { # first line will already have the indent
					$output .= $indent;
				}
				$output .= "sys.stdout.write(str(";
				$output .= compile($args[$i]);
				$output .= ")";
				$output .= ")";
				if ($i < $#args) { # last line won't need a newline
					$output .= "\n";
				}
			}
		} else {
			# ordinary function call
			$output .= $name;
			$output .= "(";
			for $i (0..$#args) {
				$output .= compile($args[$i]);
				if ($i < $#args) {
					$output .= ", ";
				}
			}
			$output .= ")";
		}

	} elsif ($type eq STRING) {

		# easy mode
		my $value = $node{"value"};
		$value =~ s/"/\\"/;
		$output .= '"' . $value . '"';

	} elsif ($type eq NUMBER) {

		$output .= $node{"value"};

	} elsif ($type eq COMMENT) {

		$output .= $indent;
		$output .= "#";
		$output .= $node{"value"};
		#$output .= "\n";

	} elsif ($type eq NODE_VARIABLE) {

		if (defined $node{"index"}) {
			$output .= $node{"name"};
			$output .= "[";
			$output .= compile($node{"index"});
			$output .= "]";
		} else {
			$output .= $node{"name"};
		}

	} elsif ($type eq NODE_ASSIGNMENT) {

		my $left_ref = $node{"name"};
		my $right_ref = $node{"value"};

		$output .= compile($left_ref);
		$output .= " = ";
		$output .= compile($right_ref);
		#$output .= "\n";

	} elsif ($type eq NODE_EXPRESSION) {

		# oh boy, shit gets weird here...
		# hands up who likes an excessive number of parentheses?

		my @operands = @{$node{"children"}};

		# is it a grouping?
		if ($node{"value"}{"type"} eq PARENTHESIS_CLOSE) {
			# daaaamn this is hax.
			$output .= "(";
			$output .= compile($operands[0]);
			$output .= ")";
		} else {

			my $opstring = op_to_string($node{"value"});

			if (@operands == 2) {

				# binary operator
				$output .= compile($operands[0]);
				$output .= " $opstring ";
				$output .= compile($operands[1]);

			} elsif (@operands == 1) {
				# unary operator
				$output .= "$opstring ";
				$output .= compile($operands[0]);
			} else {
				die "Unexpected number of operands";
			}

		}

	} else {

		die "Unable to compile $type";

	}

	return $output;
}

# --== MAIN STUFF ==--

# create list of files from arguments
@files = @ARGV;
# if it's empty, add stdin
if (@ARGV == 0) {
	push @files, "-";
}

foreach $file (@files) {

	open(F, "< $file");

	$data = "";
	while (<F>) {
		$data .= $_;
	}

	print "\n", "-" x 50, "\n";

	# initialise parser shiz
	@tokens = tokenise($data);
	$upto = 0;
	print "TOKENISING\n\n";
	print Dumper(\@tokens);
	print "\n", "-" x 50, "\n";

	#foreach $token (@tokens) {
	#	print "token: $token ", %{$token}, "\n";
	#}

	$tree_ref = parse();
	print "PARSING\n\n";
	print Dumper($tree_ref);
	print "\n", "-" x 50, "\n";

	#next;

	print "COMPILING\n\n";
	$output = "import sys\n";
	$output .= compile($tree_ref) . "\n";
	print "\n\n";
	print $output;

}